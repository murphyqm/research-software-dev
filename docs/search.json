[
  {
    "objectID": "version_control/version_control_slides.html#what-is-version-control",
    "href": "version_control/version_control_slides.html#what-is-version-control",
    "title": "Version control",
    "section": "What is version control?",
    "text": "What is version control?\n\n\nOften described as “track changes”, although that’s not quite right\nA super-powerful “undo” button\nA way of working collaboratively without over-writing each other’s work\nA way of recording exactly what you did and when",
    "crumbs": [
      "Home",
      "Version control with git",
      "Version control intro slides"
    ]
  },
  {
    "objectID": "version_control/version_control_slides.html#what-is-version-control-1",
    "href": "version_control/version_control_slides.html#what-is-version-control-1",
    "title": "Version control",
    "section": "What is version control?",
    "text": "What is version control?\n\nOne way of doing version control…",
    "crumbs": [
      "Home",
      "Version control with git",
      "Version control intro slides"
    ]
  },
  {
    "objectID": "version_control/version_control_slides.html#what-is-version-control-2",
    "href": "version_control/version_control_slides.html#what-is-version-control-2",
    "title": "Version control",
    "section": "What is version control?",
    "text": "What is version control?\n\nWe’re going to use git, which is a strangely named version control software\nWe’ll use this to explain how version control works, and why it matters\nThere are lots of other ways to do version control, but git is very widely used\n\nIf version control was word processing, git would be Microsoft Word",
    "crumbs": [
      "Home",
      "Version control with git",
      "Version control intro slides"
    ]
  },
  {
    "objectID": "version_control/version_control_slides.html#what-does-git-do",
    "href": "version_control/version_control_slides.html#what-does-git-do",
    "title": "Version control",
    "section": "What does git do?",
    "text": "What does git do?\n\ngit allows you to bundle up changes to various files, and give the group of changes a unique commit hash and an explanatory message.\ngit works on a project level, so you can make a bunch of changes to different files in a folder, and then commit all those changes with a descriptive message\nIt’s recorded that you made those changes, and there’s a unique commit hash that you can quote to point at the exact state of your folder when you added those changes.",
    "crumbs": [
      "Home",
      "Version control with git",
      "Version control intro slides"
    ]
  },
  {
    "objectID": "version_control/version_control_slides.html#what-does-git-do-1",
    "href": "version_control/version_control_slides.html#what-does-git-do-1",
    "title": "Version control",
    "section": "What does git do?",
    "text": "What does git do?\n\n\nOld version of python-file.py\n\n1 # This is a comment\n2 import matplotlib.pyplot as plt\n3 x = [1, 2, 3, 4, 5]\n4 y = [3, 4, 5, 6, 7]\n5 plt.scatter(x, y)\n\n\nNew version of python-file.py\n\n1 # This is a comment\n2 import matplotlib.pyplot as plt\n3 import numpy as np\n4 x = [1, 2, 3, 4, 5]\n5 y = [3, 4, 5, 6, 7]\n6 plt.scatter(x, y)\n6 plt.plot(x, y)\n\nLine 3 added, line 6 removed, line 6 added.",
    "crumbs": [
      "Home",
      "Version control with git",
      "Version control intro slides"
    ]
  },
  {
    "objectID": "managing-dependencies/conda-pres.html#what-is-conda",
    "href": "managing-dependencies/conda-pres.html#what-is-conda",
    "title": "The Art of conda",
    "section": "What is conda?",
    "text": "What is conda?\n\nConda is a widely used package management system\nThis allows you to isolate different Python “environments” from each other, allowing you to use different versions of libraries or modules for different projects.\nHowever, mismanagement of packages can lead to dependency hell with tangled environments and incompatible versions of different modules."
  },
  {
    "objectID": "managing-dependencies/conda-pres.html#dependency-hell",
    "href": "managing-dependencies/conda-pres.html#dependency-hell",
    "title": "The Art of conda",
    "section": "Dependency hell",
    "text": "Dependency hell\n\nPython dependencies can get very messy…"
  },
  {
    "objectID": "managing-dependencies/conda-pres.html#installing-conda-fun-licensing-details",
    "href": "managing-dependencies/conda-pres.html#installing-conda-fun-licensing-details",
    "title": "The Art of conda",
    "section": "Installing conda: fun licensing details",
    "text": "Installing conda: fun licensing details\n\nIn order to use conda on your machine, I recommend you use the MiniForge installer, which by default loads packages from conda-forge.\n\nIf you are using Anaconda (provided by Anaconda.com), ensure you are not using the defaults channel to install packages as this falls under the recent Anaconda repository licensing changes.\n\nTl;dr: stick to open source to avoid licensing issues, by using a tool such as Miniforge which by default downloads packages from conda-forge and not proprietary channels."
  },
  {
    "objectID": "managing-dependencies/conda-pres.html#the-key-to-conda-the-.yml-file",
    "href": "managing-dependencies/conda-pres.html#the-key-to-conda-the-.yml-file",
    "title": "The Art of conda",
    "section": "The key to conda: the .yml file",
    "text": "The key to conda: the .yml file\nDespite the fact conda is very widely used, especially in research, science, and data science fields, people often neglect the real magic of the system: the environment.yml file. This file is the recipe or configuration for your environment.\n\nWho here regularly uses environment.yml files in their workflow?"
  },
  {
    "objectID": "managing-dependencies/conda-pres.html#whats-yaml-or-yml",
    "href": "managing-dependencies/conda-pres.html#whats-yaml-or-yml",
    "title": "The Art of conda",
    "section": "What’s Yaml or yml?",
    "text": "What’s Yaml or yml?\nYAML is a human readable format for plain text files (usually with the file ending .yml), often used for configuration of other programs.\n\nYAML initially stood for “Yet Another Markup Language”, but now has the recursive acronym “YAML Ain’t Markup Language”, because reasons\n¯\\_(ツ)_/¯\n\nIt’s the format environment.yml files are written in."
  },
  {
    "objectID": "managing-dependencies/conda-pres.html#whats-in-a-yml-file",
    "href": "managing-dependencies/conda-pres.html#whats-in-a-yml-file",
    "title": "The Art of conda",
    "section": "What’s in a yml file?",
    "text": "What’s in a yml file?\nWhat does a .yml file look like?\nname: my-env-name\n\ndependencies:\n  - python=3.12\n  - pytest\n  - setuptools\n  - blackd\n  - isort\n  - numpy\n  - matplotlib\n  - pandas\nWe just need to create a plain text file called environment.yml or something else sensible, and list the packages we need!"
  },
  {
    "objectID": "managing-dependencies/conda-pres.html#create-a-new-environment",
    "href": "managing-dependencies/conda-pres.html#create-a-new-environment",
    "title": "The Art of conda",
    "section": "Create a new environment",
    "text": "Create a new environment\nWe can then turn this into a conda environment:\n\nOpen up the terminal in the folder with our environment.yml file\nrun the following command:\n\nconda env create -f environment.yml\nYou’ll get a lot of output, as it finds the various packages online and goes about solving all your dependencies in the background."
  },
  {
    "objectID": "managing-dependencies/conda-pres.html#why-use-a-.yml-file",
    "href": "managing-dependencies/conda-pres.html#why-use-a-.yml-file",
    "title": "The Art of conda",
    "section": "Why use a .yml file?",
    "text": "Why use a .yml file?\nCan’t I just create a fresh environment from the command line like this?\nconda create -n ENV-NAME python=3.12 numpy\nAnd then activate it and add dependencies like this?\nconda install pytest\nYou absolutely can, but theres a few reasons why you shouldn’t."
  },
  {
    "objectID": "managing-dependencies/conda-pres.html#why-not",
    "href": "managing-dependencies/conda-pres.html#why-not",
    "title": "The Art of conda",
    "section": "Why not?",
    "text": "Why not?\n\nThings you install later (e.g. pytest on the last slide) will be pinned by the versions of libraries installed at an earlier stage (so the base python version and numpy), which can lead to dependency conflicts.\nYou can end up with a lot of crud and old unneeded libraries that you no longer used bloating your environment.\nYou don’t have a nice, tidy record of what you installed and when."
  },
  {
    "objectID": "managing-dependencies/conda-pres.html#so-how-do-we-add-things",
    "href": "managing-dependencies/conda-pres.html#so-how-do-we-add-things",
    "title": "The Art of conda",
    "section": "So how do we add things?",
    "text": "So how do we add things?\nIf you want to add a new package that you didn’t include in your original environment.yml file, or pin a package to a specific version, you can go and do so within the environment.yml.\n\nJust add any new packages to the list of dependencies, and pin libraries with the = notation as in the first example.\nOnce your environment.yml file is up to date, you can apply the changes to your conda environment:\n\n\nconda env update --file environment.yml --prune\n\n\n\nThe --prune argument here clears out old unused libraries and is key to keeping your .conda folder a reasonable size."
  },
  {
    "objectID": "managing-dependencies/conda-pres.html#why-does-this-work",
    "href": "managing-dependencies/conda-pres.html#why-does-this-work",
    "title": "The Art of conda",
    "section": "Why does this work?",
    "text": "Why does this work?\n\nRunning conda install package-name from within your environment can lead to dependency conflicts (say your env has an older version of numpy and you’ve tried to conda install another package that can’t support this)\nUpdating the environment from the .yml file allows the solver to work through the dependencies at the same time. There may still be conflicts, but many easily avoidable issues will disappear."
  },
  {
    "objectID": "managing-dependencies/conda-pres.html#myth-the-env.yml-is-too-prescriptive",
    "href": "managing-dependencies/conda-pres.html#myth-the-env.yml-is-too-prescriptive",
    "title": "The Art of conda",
    "section": "Myth: the env.yml is too prescriptive",
    "text": "Myth: the env.yml is too prescriptive\n\nYou may have struggled building a conda environment from a yml file before\nThis yml file may have had lots of pinned dependencies that don’t work on the system you are trying to install on\nThis leads people to think that environment files are too prescriptive/restrictive and not useful for sharing environments\nThis conda environment file may have been built with the conda env export command - let’s learn about it!"
  },
  {
    "objectID": "managing-dependencies/conda-pres.html#exporting-a-conda-env",
    "href": "managing-dependencies/conda-pres.html#exporting-a-conda-env",
    "title": "The Art of conda",
    "section": "Exporting a conda env",
    "text": "Exporting a conda env\nSay you have a conda environment file similar to the one shown below, with very minimal pinned dependencies. For the sake of reproducibility, you want a better record of exactly what libraries you used, right?\nname: my-env-name\n\ndependencies:\n  - python=3.12\n  - pytest\n  - setuptools\n  - blackd\n  - isort\n  - numpy\n  - matplotlib\n  - pandas"
  },
  {
    "objectID": "managing-dependencies/conda-pres.html#exporting-a-conda-env-1",
    "href": "managing-dependencies/conda-pres.html#exporting-a-conda-env-1",
    "title": "The Art of conda",
    "section": "Exporting a conda env",
    "text": "Exporting a conda env\nThis is where the export option comes in. From inside your active environment, simply run:\n\nconda env export &gt; env-record.yml\n\n\n\nThe command above will export an extremely detailed list of everything in your environment (including background dependencies and their exact version numbers) to the file env-record.yml.\nSometimes, you might find it appropriate to export this to a filename with the date, for example 2024-11-27-env-record.yml."
  },
  {
    "objectID": "managing-dependencies/conda-pres.html#env.yml-files-being-restrictive",
    "href": "managing-dependencies/conda-pres.html#env.yml-files-being-restrictive",
    "title": "The Art of conda",
    "section": "env.yml files being restrictive",
    "text": "env.yml files being restrictive\nThis is where the myth of the conda env.yml being prohibitively restrictive comes in:\n\npeople often try to use this exported file to build a replica of the same environment on a different machine\nhowever this exported file contains specific details of backends and builds that will likely not be transferrable across different computers.\n\nThis is why I prefer to export it into a file name like env-record instead of just environment: it makes it very obvious this is recording the state of the environment as opposed to building a recipe to rebuild it."
  },
  {
    "objectID": "managing-dependencies/conda-pres.html#exporting-conda-environments",
    "href": "managing-dependencies/conda-pres.html#exporting-conda-environments",
    "title": "The Art of conda",
    "section": "Exporting conda environments",
    "text": "Exporting conda environments\nThis exported environment file is mainly useful as a record for the sake of reproducibility, not for reusability.\nIf you produce results with your code that are being used in some form of research output (e.g. a paper), export your environment at the time when the results are being generated, so you have a record of the versions of different libraries you used.\n\nThis is why I said it is good to build and update your environment from your environment.yml file: that way you have a reusable recipe that you can share and use to rebuild your environment, but you can also use export to get a super detailed snapshot for any sets of results!"
  },
  {
    "objectID": "managing-dependencies/conda-pres.html#more-exporting",
    "href": "managing-dependencies/conda-pres.html#more-exporting",
    "title": "The Art of conda",
    "section": "More exporting",
    "text": "More exporting\nIf you ignored all my advice about not building a haphazard environment incrementally with conda install, there is still hope: you can use the --from-history flag comes in to play:\n\nconda env export --from-history &gt; environment.yml # again, from inside the activated env\n\nThis will produce a clean conda environment file similar to the example we gave at the start of this post, listing only the packages directly explicitly installed (without background dependencies or build details).\nHowever, things will get messy if you start adding in pip dependencies…"
  },
  {
    "objectID": "managing-dependencies/conda-pres.html#mixing-in-pip",
    "href": "managing-dependencies/conda-pres.html#mixing-in-pip",
    "title": "The Art of conda",
    "section": "Mixing in pip",
    "text": "Mixing in pip\nUsing a conda environment.yml makes working with pip and conda together less painful.\n\nYou will have heard (or experienced first hand) that once you install pip in a conda env, everything from that point on must be pip, or you will break the environment.\nThis is true, but you can get around this by adding your pip dependencies to your environment.yml file."
  },
  {
    "objectID": "managing-dependencies/conda-pres.html#mixing-in-pip-1",
    "href": "managing-dependencies/conda-pres.html#mixing-in-pip-1",
    "title": "The Art of conda",
    "section": "Mixing in pip",
    "text": "Mixing in pip\nJust add your pip dependencies to your environment file, then run conda env update --file environment.yml --prune as previously described:\nname: env-with-pip-dependencies\ndependencies:\n# Whatever packages you need for your project\n  - python=3.12\n  - numpy\n  - matplotlib\n  - pandas\n  - pip\n  - pip:\n    - black\n    - https://github.com/YOUR-USERNAME/YOUR-REPO-NAME/releases/download/YOUR-VERSION-NAME/PACKAGENAME-VERSION.tar.gz # you can even install your own packages that you host on GitHub\nYou can update this as described above."
  },
  {
    "objectID": "managing-dependencies/conda-pres.html#exporting-with-pip",
    "href": "managing-dependencies/conda-pres.html#exporting-with-pip",
    "title": "The Art of conda",
    "section": "Exporting with pip",
    "text": "Exporting with pip\nExporting the full record works the same if you have pip dependencies:\nconda env export &gt; env-record.yml\nHowever, --from-history will not include pip dependencies…"
  },
  {
    "objectID": "managing-dependencies/conda-pres.html#exporting-with-pip---advanced",
    "href": "managing-dependencies/conda-pres.html#exporting-with-pip---advanced",
    "title": "The Art of conda",
    "section": "Exporting with pip - advanced",
    "text": "Exporting with pip - advanced\nHowever, --from-history will not include pip dependencies…\nIf you’ve followed our advice until now (and built your conda environment from a file), this won’t be an issue.\nBut if you ignored us or are trying to salvage old code, thankfully, there are a few different workarounds!\nThis is outside of the scope of the talk today, but the instructions for exporting are here:\nModified from this conversation on GitHub, this code snippet will export your conda and pip dependencies without version numbers (so that the environment.yml file can be used to build a new environment):\n# Extract installed pip packages\npip_packages=$(conda env export | grep -A9999 \".*- pip:\" | grep -v \"^prefix: \" | cut -f1 -d\"=\")\n\n# Export conda environment without builds, and append pip packages\nconda env export --from-history | grep -v \"^prefix: \" &gt; new-environment.yml\necho \"$pip_packages\" &gt;&gt; new-environment.yml\nBut remember: it is better to keep your environment.yml file current, and update your conda env from this file, as opposed to adding packages using conda install and then trying to export details to your environment file to track these changes."
  },
  {
    "objectID": "managing-dependencies/conda-pres.html#a-general-workflow",
    "href": "managing-dependencies/conda-pres.html#a-general-workflow",
    "title": "The Art of conda",
    "section": "A general workflow",
    "text": "A general workflow\n\nCreate your conda environment from an environment file, and update/add packages to your environment by using this file. You can keep this environment file version controlled with git alongside your code.\nExport your conda environment to a record file when you change it and produce results with it. You can keep this environment record file version controlled with git alongside your results."
  },
  {
    "objectID": "managing-dependencies/conda-pres.html#reproducibility-vs-reusability",
    "href": "managing-dependencies/conda-pres.html#reproducibility-vs-reusability",
    "title": "The Art of conda",
    "section": "Reproducibility vs reusability",
    "text": "Reproducibility vs reusability\nRemember that for reusability, you want:\n\nAn easy-to install conda environment, that works across different computers.\nYou can share this with your code to make your work more open\n\nFor reproducibility, you need the code to be reusable, but also:\n\nYou want an exact record of the environment as it was when you produced your results.\n\nEnvironments should be treated as disposable and easily rebuildable, we can use version control and tests to make sure that’s true."
  },
  {
    "objectID": "managing-dependencies/dep-pres.html#what-are-dependencies",
    "href": "managing-dependencies/dep-pres.html#what-are-dependencies",
    "title": "Managing Dependencies",
    "section": "What are dependencies?",
    "text": "What are dependencies?\nDependencies are the versions of various different modules, packages, or software that your research code depends on: all of your imports.\n\n\n\n\nDon’t be like Ruby and Avi! Record your dependencies.\n\nImage CC BY Candace Savonen, retrieved from Reproducibility in Cancer Informatics.",
    "crumbs": [
      "Home",
      "Managing dependencies",
      "Dependency slides"
    ]
  },
  {
    "objectID": "managing-dependencies/dep-pres.html#general-rules-for-dependencies",
    "href": "managing-dependencies/dep-pres.html#general-rules-for-dependencies",
    "title": "Managing Dependencies",
    "section": "General Rules for Dependencies",
    "text": "General Rules for Dependencies\nManaging dependencies is something many, many people find complicated and difficult. Let’s start with some key ideas to simplify things.\nNYU Libraries provide some straightforward guidance that is language agnostic:\n\nUse dependencies wisely and sparingly: don’t import dependencies you don’t actually use, and try to stick to libraries that have robust and stable releases.\nUse a package manager of some form: package management software, virtual environments and containers help to avoid conflicts and incompatibility errors between packages.\nRecord your dependencies in a metadata file: package managers will often do this automatically for you; this file should be both human and machine readable.",
    "crumbs": [
      "Home",
      "Managing dependencies",
      "Dependency slides"
    ]
  },
  {
    "objectID": "managing-dependencies/dep-pres.html#package-management-software",
    "href": "managing-dependencies/dep-pres.html#package-management-software",
    "title": "Managing Dependencies",
    "section": "Package management software",
    "text": "Package management software\nPackage management software usually:\n\n\nProvides a way for you to create an environment:\n\nA code project environment will contain a selection of relevant libraries, with specific versions.\nThis is kept separate from other project environments.\nThis allows you to use different versions of libraries for different projects.\n\nProvides a way for you to export your environment:\n\nThis allows you to specify the exact libraries and library versions that were used to generate a set of results.\nThis makes it easier for others to use your work and built on it, and reproduce your code environment.\nThis saves you having to manually record library versions that you are using.",
    "crumbs": [
      "Home",
      "Managing dependencies",
      "Dependency slides"
    ]
  },
  {
    "objectID": "managing-dependencies/dep-pres.html#how-do-you-pick",
    "href": "managing-dependencies/dep-pres.html#how-do-you-pick",
    "title": "Managing Dependencies",
    "section": "How do you pick?",
    "text": "How do you pick?\n1. License\n\nDoes the package manager have an open-source license?\n\n2. Community\n\nWhat solution does your research group use? Does your supervisor have suggestions?\nWhat option can you find support for?\nWhat do researchers in your field use?",
    "crumbs": [
      "Home",
      "Managing dependencies",
      "Dependency slides"
    ]
  },
  {
    "objectID": "managing-dependencies/dep-pres.html#where-to-next",
    "href": "managing-dependencies/dep-pres.html#where-to-next",
    "title": "Managing Dependencies",
    "section": "Where to next?",
    "text": "Where to next?\nIf you want some more background information and theory:\n\nReturn to the dependencies section of the course notes and keep reading.\n\nIf you want to learn by doing, get straight into it by following the instructions here:\n\nJump right in an start using conda by following this conda use blog post.",
    "crumbs": [
      "Home",
      "Managing dependencies",
      "Dependency slides"
    ]
  },
  {
    "objectID": "week-1-homework.html",
    "href": "week-1-homework.html",
    "title": "Homework",
    "section": "",
    "text": "Some content\n\n\n\n Back to top"
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#introduction-to-linux",
    "href": "intro-to-linux-files/linux101.html#introduction-to-linux",
    "title": "Linux 101",
    "section": "Introduction to Linux",
    "text": "Introduction to Linux\nAims of this training:\n\nIntroduce you to using command line interface (CLI) Linux\nBuild your confidence in navigating Linux file systems using the command line\nEnable you to use Linux without a graphical user interface (GUI)\nPrepare you for HPC1: Introduction to High Performance Computing\n\n\n\nThis is a brief, introductory level session.\nDo not assume knowledge of file systems/directory structures/other computing background.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#format-of-this-course",
    "href": "intro-to-linux-files/linux101.html#format-of-this-course",
    "title": "Linux 101",
    "section": "Format of this course",
    "text": "Format of this course\n\nThis is a 2.5 hour tutorial. We will be trying out what we are learning, so be ready for some typing!\nThese lecture slides are based on the Software Carpentries documentation on Unix Shell basics, but is a shorter course and uses different examples.\nOnce you finish this tutorial, we recommend you read through the Software Carpentries material and follow through the tutorial there: you can do this work from the same virtual machine we will be using today.\n\n\n\nWe include notes at the end on how to use our virtual machine to run the Software Carpentries material",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#format-of-these-slides",
    "href": "intro-to-linux-files/linux101.html#format-of-these-slides",
    "title": "Linux 101",
    "section": "Format of these slides",
    "text": "Format of these slides\n\nEverything you need for this session is in these slides.\nWe recommend you have a copy open on your computer.\nIf you have enough room on your screen, have these notes and your command line side-by-side.\nThese notes should also be viewable via mobile if you don’t mind not being able to copy and paste!\nThere is a quick reference cheat sheet linked in the footer; you can return to your place in the slideshow from this cheat sheet using the back button.\n\n\n\nThe cheat sheet can be used from any point in the tutorial; you can just click the back arrow and return to the exact point in the slides",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#syllabus",
    "href": "intro-to-linux-files/linux101.html#syllabus",
    "title": "Linux 101",
    "section": "Syllabus",
    "text": "Syllabus\n\nInteracting with a computer: operating systems, GUIs and CLIs, bash\nFile systems on Linux\nNavigating filesystems from the command line\nCreating and editing files and directories\nRunning simple scripts\n\n\n\nIf we don’t manage to cover all these topics, you will be able to follow on at home.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#learning-method",
    "href": "intro-to-linux-files/linux101.html#learning-method",
    "title": "Linux 101",
    "section": "Learning method",
    "text": "Learning method\nThe aim is not for you to leave knowing loads of Linux Bash commands!\n\nThere are many fantastically useful commands we won’t cover today (read through the Software Carpentries course after this for some extra commands);\nThe aim is for you to get a feel for how Linux’s command line works, to be able to problem solve and find the commands you need.\nThis is an introductory course for complete beginners: of course, you’re welcome here if you want a refresher, but expect for the course to be slow-paced.\n\n\n\nEmphasise that the point is not to teach lots of shortcuts and commands.\nIt’s ok not to remember commands from today - the point is that if you want to do something on Linux, you’ll be better able to search for and then understand the answer.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#interacting-with-a-computer",
    "href": "intro-to-linux-files/linux101.html#interacting-with-a-computer",
    "title": "Linux 101",
    "section": "Interacting with a computer",
    "text": "Interacting with a computer\nWhen we use a computer, we interact with the hardware through an operating system or OS.\nCommon operating systems for research computers include:\n\nMicrosoft Windows\nMacOS\nLinux\n\nWe are going to be looking at Linux today, which is a family of operating systems that are Open Source and are widely used in research, for example on High Performance Computing platforms like ARC4 or Aire.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#interacting-with-a-computer-1",
    "href": "intro-to-linux-files/linux101.html#interacting-with-a-computer-1",
    "title": "Linux 101",
    "section": "Interacting with a computer",
    "text": "Interacting with a computer\nWhen we use a computer, like our desktop or laptop, we often use a Graphical User Interface or a GUI.\n\nGUIs allow us to interact with a computer through graphical means: icons, text, buttons, windows. GUIs usually involve using a mouse and clicking into menus.\nThe Windows desktop and MacOS desktop are GUIs that let you control the computer graphically.\nMany computer programs also have GUIs: for example, Excel.\n\n\n\n\nWhat are some of the benefits of GUIs? See if people have suggestions.\nWhat are some of the downsides of using GUIs?",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#interacting-with-a-computer-2",
    "href": "intro-to-linux-files/linux101.html#interacting-with-a-computer-2",
    "title": "Linux 101",
    "section": "Interacting with a computer",
    "text": "Interacting with a computer\nAs well as using a GUI, we can also interact with computers using a Command Line Interface or a CLI.\n\nCLIs allow us to interact with a computer through text-based commands typed into the command-line.\nWhile GUIs can be simple and intuitive to use, they can make it difficult to reproduce workflows:\n\nSometimes you have to record by hand (or with a screen recording) what sub-options from different menus you used;\nUpdates to GUIs can make it difficult to find the same menu options;\nA workflow with multiple steps can be tedious to repeat for multiple datasets (having to click through multiple layers of menu options for each dataset).\n\nMany large research machines (such as the HPC machines ARC4 and Aire here at Leeds) do not have a GUI and so you need to interact with them through a CLI.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#command-line-interfaces",
    "href": "intro-to-linux-files/linux101.html#command-line-interfaces",
    "title": "Linux 101",
    "section": "Command Line Interfaces",
    "text": "Command Line Interfaces\n\nThere are multiple different CLIs available:\n\nGeneral-purpose CLIs are available for each Operating System for general computer control:\n\nWindows Command Prompt;\nWindows Powershell;\nMac Terminal;\n\nSome specific programs have their own custom CLIs:\n\nAnaconda Prompt for Windows;\nGit Bash for Windows;\n\n\nToday, we are going to be using a Unix Shell:\n\nThis is the general-purpose CLI that underpins both Linux and Mac;\nWe will use Bash, a popular Unix Shell.\n\n\n\n\nEssentially, there are many different ways to access a command line, and there are different types of command line interfaces!\nWe are teaching you one today that is easy to access, and is used on research HPC systems",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#bash",
    "href": "intro-to-linux-files/linux101.html#bash",
    "title": "Linux 101",
    "section": "Bash",
    "text": "Bash\nHow do we access Bash?\n\nBash is the default shell on Unix systems like Linux or Mac\nBash is also available through many command-line tools for Windows:\n\nGit Bash for Windows\nAnaconda Prompt\n\n\nWe’re going to use a virtual machine for this course: this is a Linux machine running in the cloud.\nThis means that everyone here can run it with the exact same set-up; you only need a browser.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#file-system-on-linux",
    "href": "intro-to-linux-files/linux101.html#file-system-on-linux",
    "title": "Linux 101",
    "section": "File system on Linux",
    "text": "File system on Linux\n\n\n\n\n\n---\nconfig:\n  look: handDrawn\n---\n\nflowchart\n    \n    / o--obin\n    / o--odev\n    / o--oetc\n    / o--ohome\n    home o--omy-username\n    home o--omy-friend\n    / o--otmp\n\n    my-username o--o all_my_files\n\n\n\n\n\n\nEach rectangle is a folder or directory (dir for short)\n\n\nThis shows a sketch of a file system.\nWe have a hierarchy of folders or directories sitting inside one another.\nFolders are usually called “directories” on Linux systems, but they mean the same thing.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#file-system-on-linux-1",
    "href": "intro-to-linux-files/linux101.html#file-system-on-linux-1",
    "title": "Linux 101",
    "section": "File system on Linux",
    "text": "File system on Linux\n\n\n\n\n\n---\nconfig:\n  look: handDrawn\n---\nflowchart\n    \n    / o--obin\n    / o--odev\n    / o--oetc\n    / o--ohome\n    home o--omy-username\n    home o--omy-friend\n    / o--otmp\n\n    my-username o--o all_my_files\n\n    style / fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n\n\n\n\n\n\nEach rectangle is a folder or directory (dir for short)\n\n\nThis branching system starts from the root (the forward slash) at the very top, highlighted in pink.\nInside this root directory, we have a bunch of system folders - we don’t need to worry about these now.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#file-system-on-linux-2",
    "href": "intro-to-linux-files/linux101.html#file-system-on-linux-2",
    "title": "Linux 101",
    "section": "File system on Linux",
    "text": "File system on Linux\n\n\n\n\n\n---\nconfig:\n  look: handDrawn\n---\n\nflowchart\n    \n    / o--obin\n    / o--odev\n    / o--oetc\n    / o--ohome\n    home o--omy-username\n    home o--omy-friend\n    / o--otmp\n\n    my-username o--o all_my_files\n\n    style home fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n\n\n\n\n\n\nEach rectangle is a folder or directory (dir for short)\n\n\nOne of the directories is called “home”: this contains all the home directories of users.\nThe home directories are usually called after their owner’s username.\nIf you look in this directory on a personal or family computer, you might find a handful of user home directories\nIf you look at this directory on a university HPC system, like Aire, you’ll find hundreds of user home directories",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#file-system-on-linux-3",
    "href": "intro-to-linux-files/linux101.html#file-system-on-linux-3",
    "title": "Linux 101",
    "section": "File system on Linux",
    "text": "File system on Linux\n\n\n\n\n\n---\nconfig:\n  look: handDrawn\n---\n\nflowchart\n    \n    / o--obin\n    / o--odev\n    / o--oetc\n    / o--ohome\n    home o--omy-username\n    home o--omy-friend\n    / o--otmp\n\n    my-username o--o all_my_files\n\n    style my-username fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n\n\n\n\n\n\nThe my-username folder is your user home directory\n\n\nConfusingly, we refer to this highlighted directory as your home directory\nEven though there is a folder one level up that is called home!",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#file-system-on-linux-4",
    "href": "intro-to-linux-files/linux101.html#file-system-on-linux-4",
    "title": "Linux 101",
    "section": "File system on Linux",
    "text": "File system on Linux\n\n\n\n\n\n---\nconfig:\n  look: handDrawn\n---\n\nflowchart\n    \n    / o--obin\n    / o--odev\n    / o--oetc\n    / o--ohome\n    home o--omy-username\n    home o--omy-friend\n    / o--otmp\n\n    my-username o--o all_my_files\n\n    style my-username fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n\n\n\n\n\n\nHow do we describe the address of this home directory?\n\n\nHow do we describe where this directory or folder is?\nWe describe it in a similar way to a website URL, using it’s path\nWe need to know all the folders directly above it.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#file-system-on-linux-5",
    "href": "intro-to-linux-files/linux101.html#file-system-on-linux-5",
    "title": "Linux 101",
    "section": "File system on Linux",
    "text": "File system on Linux\n\n\n\n\n\n---\nconfig:\n  look: handDrawn\n---\n\nflowchart\n    \n    / o--obin\n    / o--odev\n    / o--oetc\n    / o--ohome\n    home o--omy-username\n    home o--omy-friend\n    / o--otmp\n\n    my-username o--o all_my_files\n\n    style my-username fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n    style home fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n    style / fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n\n\n\n\n\n\nThe folders in the address are /, home and my-username\n\n\nAbove our username directory, we have home and the root (which is denoted by just a forward slash)",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#file-system-on-linux-6",
    "href": "intro-to-linux-files/linux101.html#file-system-on-linux-6",
    "title": "Linux 101",
    "section": "File system on Linux",
    "text": "File system on Linux\n\n\n\n\n\n---\nconfig:\n  look: handDrawn\n---\n\nflowchart\n    \n    / o--obin\n    / o--odev\n    / o--oetc\n    / o--ohome\n    home o--omy-username\n    home o--omy-friend\n    / o--otmp\n\n    my-username o--o all_my_files\n\n    style my-username fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n    style home fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n    style / fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n\n\n\n\n\n\nStick them together like a URL: /home/my-username\n\n\nWe just have to put them together like a web address (because the internet is basically just a giant file structure)",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#file-system-on-linux-7",
    "href": "intro-to-linux-files/linux101.html#file-system-on-linux-7",
    "title": "Linux 101",
    "section": "File system on Linux",
    "text": "File system on Linux\nOn Windows, file paths use backlashes ( \\ ) instead of forward slashes (/)!\n\nThis can cause confusion and errors if you are writing scripts that load in data from certain file paths, and need to use both Windows and Linux!\nThankfully there are lots of ways around this, including libraries for handling paths in Python and R\n\n\n\nIt’s useful to note that Windows uses slashes in the opposite direction for file paths.\nWe’re not going to focus on this today as we are using only Linux\nBut if you get an error while coding it’s useful to keep this in mind.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#file-system-on-linux-8",
    "href": "intro-to-linux-files/linux101.html#file-system-on-linux-8",
    "title": "Linux 101",
    "section": "File system on Linux",
    "text": "File system on Linux\n\n\n\n\n\n---\nconfig:\n  look: handDrawn\n---\n\nflowchart\n    \n    / o--obin\n    / o--odev\n    / o--oetc\n    / o--ohome\n    home o--omy-username\n    home o--omy-friend\n    / o--otmp\n\n    my-username o--o all_my_files\n\n    style my-username fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n    style home fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n    style / fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n\n\n\n\n\n\nStick them together like a URL: /home/my-username\n\n\nBack to our file system.\nToday, everything we are doing will be in our home directory, so let’s just focus on that!\nWhen you log in to a linux system, this is usually where you will be dropped!",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#file-system-on-linux-9",
    "href": "intro-to-linux-files/linux101.html#file-system-on-linux-9",
    "title": "Linux 101",
    "section": "File system on Linux",
    "text": "File system on Linux\n\n\n\n\n\n---\nconfig:\n  look: handDrawn\n---\n\nflowchart\n    \n    / o--ohome\n    home o--omy-username\n\n    my-username o--o all_my_files\n\n    style my-username fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n    style home fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n    style / fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n\n\n\n\n\n\n/home/my-username/all_my_files is a bit long…\n\n\nTyping the full path to our files and folders is a bit tedious\nlets look at a shorter way",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#file-system-on-linux-10",
    "href": "intro-to-linux-files/linux101.html#file-system-on-linux-10",
    "title": "Linux 101",
    "section": "File system on Linux",
    "text": "File system on Linux\n\n\n\n\n\n\n\n\n\n\n---\nconfig:\n  look: handDrawn\n---\n\nflowchart\n    \n    / o--ohome\n    home o--omy-username\n\n    my-username o--o all_my_files\n\n    style my-username fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n    style home fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n    style / fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n\n\n\n\n\n\n\n\n\n\n\n---\nconfig:\n  look: handDrawn\n---\n\nflowchart\n    \n    home[\"~\"] o--o all_my_files\n\n    style home fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n\n\n\n\n\n\n\n\n\n/home/my-username/all_my_files is a bit long…\n\n\nTyping the full path to our files and folders is a bit tedious\nlets look at a shorter way",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#file-system-on-linux-11",
    "href": "intro-to-linux-files/linux101.html#file-system-on-linux-11",
    "title": "Linux 101",
    "section": "File system on Linux",
    "text": "File system on Linux\n\n\n\n\n\n---\nconfig:\n  look: handDrawn\n---\n\nflowchart\n    \n    home[\"~\"] o--o all_my_files\n\n    style home fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n\n\n\n\n\n\n\nTo save us from typing out /home/my-username every time we refer to a directory or file, we can use the shortcut ~, called a tilde\nThis turns /home/my-username/all_my_files to ~/all_my_files",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#lets-explore-some-files",
    "href": "intro-to-linux-files/linux101.html#lets-explore-some-files",
    "title": "Linux 101",
    "section": "Let’s explore some files!",
    "text": "Let’s explore some files!\nTime to explore some files on a Linux system!\n\n\n\n\n\n---\nconfig:\n  look: handDrawn\n---\n\nflowchart TD\n    A[\"/home/vscode/ &lt;br&gt; or ~\"] o--o B[red-folder]\n    A o--o C[pink-folder]\n    A o--o D[blue-folder]\n\n    B o--o r1([red-1.txt ])\n    B o--o r2([red-2.txt ])\n    B o--o r3([red-3.txt ])\n\n    C o--o P1[pink-sub-folder]\n    C o--o p2([\"pink-file.md &lt;br&gt;\"])\n    C o--o p3{{\"say_hi.sh &lt;br&gt;\"}}\n\n    P1 o--o p4([\"**helloworld.py** &lt;br&gt;\"])\n    P1 o--o p5([\"pink-data.csv &lt;br&gt;\"])\n\n    D o--o b1([\"**blue.r** &lt;br&gt;\"])",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#using-our-custom-virtual-machine",
    "href": "intro-to-linux-files/linux101.html#using-our-custom-virtual-machine",
    "title": "Linux 101",
    "section": "Using our custom virtual machine",
    "text": "Using our custom virtual machine\nFor this course, we’ve built a custom virtual machine for you to use.\nThis requires a GitHub account which you were asked to set up before this course.\n(Don’t worry if you haven’t - please go and quickly sign up to GitHub now!)\n\nThere are many other ways to access the bash shell, such as on one of the HPC systems here at Leeds, or by installing git bash on Windows, or using the terminal on Linux or Mac.\nWe want everyone in the class to have the same directory structure and environment which is why we are using a virtual machine!",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#launch-virtual-machine",
    "href": "intro-to-linux-files/linux101.html#launch-virtual-machine",
    "title": "Linux 101",
    "section": "Launch virtual machine",
    "text": "Launch virtual machine\n\nStep 1Step 2Step 3\n\n\nOne of the pre-requisites for this course was signing up for an account with GitHub, as this is the service we use to host the virtual Linux machines for teaching this session.\nLog in to GitHub now (or sign up if you haven’t already).\n\n\nFollow this link to open the course repository.\n\n\nThere will be a green button with the word “Code”, which will then bring up a menu when clicked.\n\n\n\n\n\n\n\n\n\n\n\n↑ Click this button, this menu opens →",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#the-terminal",
    "href": "intro-to-linux-files/linux101.html#the-terminal",
    "title": "Linux 101",
    "section": "The terminal",
    "text": "The terminal\nOnce you’ve launched your virtual machine, you will see a terminal window something like this:\n\n_\n_@username → /workspaces/bash-codespaces-template (main) $ ▮\n_\n\n\n\n_\n_@username → /workspaces/bash-codespaces-template (main) $ ▮\n_\n\nThe underlined section is your directory path.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#the-terminal-1",
    "href": "intro-to-linux-files/linux101.html#the-terminal-1",
    "title": "Linux 101",
    "section": "The terminal",
    "text": "The terminal\nOnce you’ve launched your virtual machine, you will see a terminal window something like this:\n\n_\n_@username → /workspaces/bash-codespaces-template (main) $ ▮\n_\n\n\n\n_\n_@username → /workspaces/bash-codespaces-template (main) $ ▮\n_\n\nThe underlined section has to do with the git version control system: not a topic for today, but you can learn about this in SWD2!",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#the-terminal-2",
    "href": "intro-to-linux-files/linux101.html#the-terminal-2",
    "title": "Linux 101",
    "section": "The terminal",
    "text": "The terminal\nOnce you’ve launched your virtual machine, you will see a terminal window something like this:\n\n_\n_@username → /workspaces/bash-codespaces-template (main) $ ▮\n_\n\n\n\nThe dollar symbol ($) and rectangle (▮) on the right hand side are the end of the prompt and the cursor.\n\nThe $ tells you where the computer’s message ends, and where you can enter your commands.\nThe ▮ (which will probably be slowly flashing) tells you where the cursor is; this often looks more like a vertical line ( | ) in other programs like Word.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#the-terminal-3",
    "href": "intro-to-linux-files/linux101.html#the-terminal-3",
    "title": "Linux 101",
    "section": "The terminal",
    "text": "The terminal\nIf you click on the ▮ or the space just to the right of the $ you can type in your message:\n\n_\n_@username → /workspaces/bash-codespaces-template (main) $ hello▮\n_\n\nAnything you type will be in white text in the terminal; the cursor will blink at the end of the text.\nTo send the argument or message, you need to press ENTER on your keyboard.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#the-terminal-4",
    "href": "intro-to-linux-files/linux101.html#the-terminal-4",
    "title": "Linux 101",
    "section": "The terminal",
    "text": "The terminal\nIf you click on the ▮ or the space just to the right of the $ you can type in your message:\n\n_\n_@username → /folders (main) $ this is the code you type ↵\n_\n\n\nThe code you need to type/copy and paste is shown in bold white\nWe will hide the cursor and fade the prompt ($) to grey\nWe will show an ENTER symbol in pink to remind you how to enter the command (↵)",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#very-first-command-cd",
    "href": "intro-to-linux-files/linux101.html#very-first-command-cd",
    "title": "Linux 101",
    "section": "Very first command: cd",
    "text": "Very first command: cd\nWe’re going to use the cd command to bring us to our home directory.\n\n_\n_@username → /folders (main) $ ▮\n\n_@username → /folders (main) $ cd ↵\n\n\n_@username → ~ $ ▮\n\n_",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#very-first-command-cd-1",
    "href": "intro-to-linux-files/linux101.html#very-first-command-cd-1",
    "title": "Linux 101",
    "section": "Very first command: cd",
    "text": "Very first command: cd\n\ncd stands for change directory\nIt brings us back to our home directory, ~ or /home/vscode\n\n\n\nOur virtual machine is a little bit weird because it starts us off in a different folder: on most Linux systems, when you log in, you will immediately be in your home directory\n\n\n\n_@username → ~ $ ▮",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#whats-in-this-folder",
    "href": "intro-to-linux-files/linux101.html#whats-in-this-folder",
    "title": "Linux 101",
    "section": "What’s in this folder?",
    "text": "What’s in this folder?\nNow that you know how to find home (from wherever in the file system you are), you need to know what’s in your home directory.\n\nYou can list out the files and folders in your directory with the command ls",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#whats-in-this-folder-ls-to-list",
    "href": "intro-to-linux-files/linux101.html#whats-in-this-folder-ls-to-list",
    "title": "Linux 101",
    "section": "What’s in this folder? ls to list",
    "text": "What’s in this folder? ls to list\nUsing the ls command to list out the contents of the directory:\n\n_\n_@username → ~ $ ▮\n\n_@username → ~ $ ls ↵\n\n\n_blue-folder pink-folder red-folder\n_@username → ~ $ ▮\n\n_",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#whats-in-this-folder-ls-to-list-1",
    "href": "intro-to-linux-files/linux101.html#whats-in-this-folder-ls-to-list-1",
    "title": "Linux 101",
    "section": "What’s in this folder? ls to list",
    "text": "What’s in this folder? ls to list\nHow do we know if blue-folder is a file or a directory? (imagine it has a less descriptive name)\n\n_@username → ~ $ ls ↵\n_blue-folder pink-folder red-folder\n_@username → ~ $ ▮\n\n_@username → ~ $ ls -F ↵",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#whats-in-this-folder-ls-to-list-2",
    "href": "intro-to-linux-files/linux101.html#whats-in-this-folder-ls-to-list-2",
    "title": "Linux 101",
    "section": "What’s in this folder? ls to list",
    "text": "What’s in this folder? ls to list\nWe can use ls -F: this tells us the category of the “things” in the directory\n\nIf the name ends in a trailing forward slash (like this/) then the item is a directory or folder\n\n\n_@username → ~ $ ls -F ↵\n_blue-folder/ pink-folder/ red-folder/\n_@username → ~ $ ▮",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#whats-in-this-folder-ls-to-list-3",
    "href": "intro-to-linux-files/linux101.html#whats-in-this-folder-ls-to-list-3",
    "title": "Linux 101",
    "section": "What’s in this folder? ls to list",
    "text": "What’s in this folder? ls to list\nThis is what we expected: we saw in our directory map that we have three directories in our home (~): red-folder, pink-folder, and blue-folder.\n\n\n\n\n\n---\nconfig:\n  look: handDrawn\n---\n\nflowchart TD\n    A[\"/home/vscode/ &lt;br&gt; or ~\"] o--o B[red-folder]\n    A o--o C[pink-folder]\n    A o--o D[blue-folder]\n\n    B o--o r1([red-1.txt ])\n    B o--o r2([red-2.txt ])\n    B o--o r3([red-3.txt ])\n\n    C o--o P1[pink-sub-folder]\n    C o--o p2([\"pink-file.md &lt;br&gt;\"])\n    C o--o p3{{\"say_hi.sh &lt;br&gt;\"}}\n\n    P1 o--o p4([\"**helloworld.py** &lt;br&gt;\"])\n    P1 o--o p5([\"pink-data.csv &lt;br&gt;\"])\n\n    D o--o b1([\"**blue.r** &lt;br&gt;\"])",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#whats-in-this-folder-ls-to-list-4",
    "href": "intro-to-linux-files/linux101.html#whats-in-this-folder-ls-to-list-4",
    "title": "Linux 101",
    "section": "What’s in this folder? ls to list",
    "text": "What’s in this folder? ls to list\nLet’s list what’s inside pink-folder…\n\n\n\n\n\n---\nconfig:\n  look: handDrawn\n---\n\nflowchart TD\n    A[\"/home/vscode/ &lt;br&gt; or ~\"] o--o B[red-folder]\n    A o--o C[pink-folder]\n    A o--o D[blue-folder]\n\n    B o--o r1([red-1.txt ])\n    B o--o r2([red-2.txt ])\n    B o--o r3([red-3.txt ])\n\n    C o--o P1[pink-sub-folder]\n    C o--o p2([\"pink-file.md &lt;br&gt;\"])\n    C o--o p3{{\"say_hi.sh &lt;br&gt;\"}}\n\n    P1 o--o p4([\"**helloworld.py** &lt;br&gt;\"])\n    P1 o--o p5([\"pink-data.csv &lt;br&gt;\"])\n\n    D o--o b1([\"**blue.r** &lt;br&gt;\"])",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#whats-in-this-folder-ls-to-list-5",
    "href": "intro-to-linux-files/linux101.html#whats-in-this-folder-ls-to-list-5",
    "title": "Linux 101",
    "section": "What’s in this folder? ls to list",
    "text": "What’s in this folder? ls to list\nWe can use ls name-of-folder to tell us what’s in a sub-directory.\nWhat will the output be?\n\n_@username → ~ $ ls pink-folder ↵\n\n_pink-file.md pink-subfolder say_hi.sh",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#whats-in-this-folder-ls-to-list-6",
    "href": "intro-to-linux-files/linux101.html#whats-in-this-folder-ls-to-list-6",
    "title": "Linux 101",
    "section": "What’s in this folder? ls to list",
    "text": "What’s in this folder? ls to list\nWe can use ls -F name-of-folder to tell us what’s in a sub-directory and what category the items are.\nWhat will the output be?\n\n_@username → ~ $ ls -F pink-folder ↵\n\n_pink-file.md pink-subfolder/ say_hi.sh*\n\n\n\n\nFiles get no added symbols;\nFolders or directories get a trailing forward slash (/);\nExecutables get an asterisk (*);",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#recap",
    "href": "intro-to-linux-files/linux101.html#recap",
    "title": "Linux 101",
    "section": "Recap",
    "text": "Recap\nSo far, we’ve used:\n\ncd on it’s own to go to our home directory;\nls on it’s own to list out the contents of our current directory (our home);\nls -F (ls with the flag or option -F) to list out the categories of the content in the directory;\nls dir-name (ls with the argument dir-name) to list out the content of the sub-directory dir-name;",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#format-of-bash-commands",
    "href": "intro-to-linux-files/linux101.html#format-of-bash-commands",
    "title": "Linux 101",
    "section": "Format of bash commands",
    "text": "Format of bash commands\nYou’ve already cracked how bash works with these few commands!\n\n_$ ls -F dir-name\n\n\n\n$ → prompt\nls → command\n-F → option\ndir-name → argument",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#adding-arguments-to-cd",
    "href": "intro-to-linux-files/linux101.html#adding-arguments-to-cd",
    "title": "Linux 101",
    "section": "Adding arguments to cd",
    "text": "Adding arguments to cd\nWe’ve used cd on it’s own to access our home directory - what happens when we give it an argument?\nWhat will the output be?\n\n_@username → ~ $ cd pink-folder ↵\n\n_@username → ~/pink-folder $ ▮\n\n\n\nWe’ve moved down our directory structure, into the directory pink-folder",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#explore-with-cd-and-ls",
    "href": "intro-to-linux-files/linux101.html#explore-with-cd-and-ls",
    "title": "Linux 101",
    "section": "Explore with cd and ls",
    "text": "Explore with cd and ls\n\nRemember, you can return to home from anywhere with cd and no options or arguments\nUse ls to find out what is in the different directories\nUse cd name-of-dir to move to a subdirectory\nUse the directory map if lost\nUse the clear command to clean up your terminal screen if it’s getting too messy:\n\n\n_@username → ~ $ clear ↵",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#getting-help",
    "href": "intro-to-linux-files/linux101.html#getting-help",
    "title": "Linux 101",
    "section": "Getting help",
    "text": "Getting help\nThere are two different ways of getting information about commands and their options and arguments within the shell:\n\nman arg\narg --help\n\nOn our virtual machine, we are going to use the section option, arg --help. Try running ls --help:\n\n_@username → ~ $ ls –help ↵",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#getting-help-1",
    "href": "intro-to-linux-files/linux101.html#getting-help-1",
    "title": "Linux 101",
    "section": "Getting help",
    "text": "Getting help\nYou’ll be faced with a wall of text and will have to scroll to find the top of it:\n\n_@username → ~ $ ls –help ↵\nUsage: ls [OPTION]… [FILE]…\nList information about the FILEs (the current directory by default).\nSort entries alphabetically if none of -cftuvSUX nor –sort is specified.\nMandatory arguments to long options are mandatory for short options too.\n-a, –all : do not ignore entries starting with .\n-A, –almost-all : do not list implied . and ..\nand on, and on, and on…",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#getting-help-2",
    "href": "intro-to-linux-files/linux101.html#getting-help-2",
    "title": "Linux 101",
    "section": "Getting help",
    "text": "Getting help\nThis can be really useful for quickly checking the arguments and options to commands you half-remember, but can also be incredibly unhelpful and overwhelming if you don’t know what you’re looking at!\n\nSearching online is your friend!\nIf you know the argument name, say ls, wrap it in quotation marks in your search to require it;\nSearch the term alongside terms like bash, linux, command line, explanation;\nFor example, I might search “ls -F” explanation\nStack Overflow and Stack Exchange (Q&A forums) can be useful sources, usually with a bit of conversation back and forth and likely some disagreement/argument about the best way of doing something.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#getting-help-3",
    "href": "intro-to-linux-files/linux101.html#getting-help-3",
    "title": "Linux 101",
    "section": "Getting help",
    "text": "Getting help\n\nWhat does the command ls -a do?\n\nCan you find an answer with ls --help?\nWhat happens if you run ls -a inside pink-folder?\nCan you find an answer by searching online?\n\n\n\n_@username → ~/somewhere $ cd ↵ go back to home\n_@username → ~ $ cd pink-folder ↵ go to folder\n_@username → ~/pink-folder $ ls -a ↵ ???",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#ls--a",
    "href": "intro-to-linux-files/linux101.html#ls--a",
    "title": "Linux 101",
    "section": "ls -a",
    "text": "ls -a\n\n_@username → ~/pink-folder $ ls -a ↵\n\n_ . .. pink-file.md pink-subfolder say_hi.sh .super-secret-hidden-file .super-secret-hidden-folder\n\n\n_@username → ~/pink-folder $ ls -F -a ↵\n\n\n_ ./ ../ pink-file.md pink-subfolder/ say_hi.sh* .super-secret-hidden-file .super-secret-hidden-folder/\n\n\n\nWhat’s in these weird directories . and ..?\n\nTry exploring them with ls . and ls ..\nTry going to them using cd . and cd ..\nYou can use the command pwd (path to the working directory) to print out exactly where you are (using /home/vscode instead of ~)",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#ls--a-1",
    "href": "intro-to-linux-files/linux101.html#ls--a-1",
    "title": "Linux 101",
    "section": "ls -a",
    "text": "ls -a\n\nWhat’s in these weird directories . and ..?\n\nTry exploring them with ls . and ls ..\nTry going to them using cd . and cd ..\nYou can use the command pwd (path to the working directory) to print out exactly where you are (using /home/vscode instead of ~)\n\n\n\nThe single dot . stands for the current directory - the place you get when you use pwd\nThe double dot .. stands for the directory above the current directory.\nIf you are currently in ~/pink-folder/pink-subfolder:\n\nThe single dot . is the folder ~/pink-folder/pink-subfolder\nThe double dot .. is the folder ~/pink-folder",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#relative-paths",
    "href": "intro-to-linux-files/linux101.html#relative-paths",
    "title": "Linux 101",
    "section": "Relative paths",
    "text": "Relative paths\nSo far, we’ve looked at absolute paths that start up at ~ or /home/vscode.\n\n\n\n\n\n---\nconfig:\n  look: handDrawn\n---\n\nflowchart TD\n    A[\"/home/vscode/ &lt;br&gt; or ~\"] o--o B[red-folder]\n    A o--o C[pink-folder]\n    A o--o D[blue-folder]\n\n    B o--o r1([red-1.txt ])\n    B o--o r2([red-2.txt ])\n    B o--o r3([red-3.txt ])\n\n    C o--o P1[pink-sub-folder]\n    C o--o p2([\"pink-file.md &lt;br&gt;\"])\n    C o--o p3{{\"say_hi.sh &lt;br&gt;\"}}\n\n    P1 o--o p4([\"**helloworld.py** &lt;br&gt;\"])\n    P1 o--o p5([\"pink-data.csv &lt;br&gt;\"])\n\n    D o--o b1([\"**blue.r** &lt;br&gt;\"])",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#relative-paths-1",
    "href": "intro-to-linux-files/linux101.html#relative-paths-1",
    "title": "Linux 101",
    "section": "Relative paths",
    "text": "Relative paths\nSo far, we’ve looked at absolute paths that start up at ~ or /home/vscode.\n\n\n\n\n\n---\nconfig:\n  look: handDrawn\n---\n\nflowchart TD\n    A[\"/home/vscode/ &lt;br&gt; or ~\"] o--o B[red-folder]\n    A o--o C[pink-folder]\n    A o--o D[blue-folder]\n\n    B o--o r1([red-1.txt ])\n    B o--o r2([red-2.txt ])\n    B o--o r3([red-3.txt ])\n\n    C o--o P1[pink-sub-folder]\n    C o--o p2([\"pink-file.md &lt;br&gt;\"])\n    C o--o p3{{\"say_hi.sh &lt;br&gt;\"}}\n\n    P1 o--o p4([\"**helloworld.py** &lt;br&gt;\"])\n    P1 o--o p5([\"pink-data.csv &lt;br&gt;\"])\n\n    D o--o b1([\"**blue.r** &lt;br&gt;\"])\n\n    style A fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n    style C fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n    style P1 fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n    style p4 fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n\n\n\n\n\n\n\n~/pink-folder/pink-sub-folder/helloworld.py",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#relative-paths-2",
    "href": "intro-to-linux-files/linux101.html#relative-paths-2",
    "title": "Linux 101",
    "section": "Relative paths",
    "text": "Relative paths\nBut if we are already in pink-folder (if it’s our working directory), we can use a relative path:\n\n\n\n\n\n---\nconfig:\n  look: handDrawn\n---\n\nflowchart TD\n    A[\"/home/vscode/ &lt;br&gt; or ~\"] o--o B[red-folder]\n    A o--o C[pink-folder]\n    A o--o D[blue-folder]\n\n    B o--o r1([red-1.txt ])\n    B o--o r2([red-2.txt ])\n    B o--o r3([red-3.txt ])\n\n    C o--o P1[pink-sub-folder]\n    C o--o p2([\"pink-file.md &lt;br&gt;\"])\n    C o--o p3{{\"say_hi.sh &lt;br&gt;\"}}\n\n    P1 o--o p4([\"**helloworld.py** &lt;br&gt;\"])\n    P1 o--o p5([\"pink-data.csv &lt;br&gt;\"])\n\n    D o--o b1([\"**blue.r** &lt;br&gt;\"])\n\n    style C fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n    style P1 fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n    style p4 fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n\n\n\n\n\n\n\npink-sub-folder/helloworld.py",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#relative-paths-3",
    "href": "intro-to-linux-files/linux101.html#relative-paths-3",
    "title": "Linux 101",
    "section": "Relative paths",
    "text": "Relative paths\nBut if we are already in pink-subfolder (if it’s our working directory), we can use a relative path:\n\n\n\n\n\n---\nconfig:\n  look: handDrawn\n---\n\nflowchart TD\n    A[\"/home/vscode/ &lt;br&gt; or ~\"] o--o B[red-folder]\n    A o--o C[pink-folder]\n    A o--o D[blue-folder]\n\n    B o--o r1([red-1.txt ])\n    B o--o r2([red-2.txt ])\n    B o--o r3([red-3.txt ])\n\n    C o--o P1[pink-sub-folder]\n    C o--o p2([\"pink-file.md &lt;br&gt;\"])\n    C o--o p3{{\"say_hi.sh &lt;br&gt;\"}}\n\n    P1 o--o p4([\"**helloworld.py** &lt;br&gt;\"])\n    P1 o--o p5([\"pink-data.csv &lt;br&gt;\"])\n\n    D o--o b1([\"**blue.r** &lt;br&gt;\"])\n\n    style P1 fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n    style p4 fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n\n\n\n\n\n\n\nhelloworld.py",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#relative-paths-4",
    "href": "intro-to-linux-files/linux101.html#relative-paths-4",
    "title": "Linux 101",
    "section": "Relative paths",
    "text": "Relative paths\nWhat if we are in pink-subfolder (if it’s our working directory), and want the path to pink-file.md?\n\n\n\n\n\n---\nconfig:\n  look: handDrawn\n---\n\nflowchart TD\n    A[\"/home/vscode/ &lt;br&gt; or ~\"] o--o B[red-folder]\n    A o--o C[pink-folder]\n    A o--o D[blue-folder]\n\n    B o--o r1([red-1.txt ])\n    B o--o r2([red-2.txt ])\n    B o--o r3([red-3.txt ])\n\n    C o--o P1[pink-sub-folder]\n    C o--o p2([\"pink-file.md &lt;br&gt;\"])\n    C o--o p3{{\"say_hi.sh &lt;br&gt;\"}}\n\n    P1 o--o p4([\"**helloworld.py** &lt;br&gt;\"])\n    P1 o--o p5([\"pink-data.csv &lt;br&gt;\"])\n\n    D o--o b1([\"**blue.r** &lt;br&gt;\"])\n\n    style P1 fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n    style p2 fill:#ff0,stroke:#333,stroke-width:10px,color:#333\n\n\n\n\n\n\n\nHint: what can we see with ls .. from the current directory?",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#poll",
    "href": "intro-to-linux-files/linux101.html#poll",
    "title": "Linux 101",
    "section": "Poll",
    "text": "Poll\nWhat if we are in pink-subfolder (if it’s our working directory), and want the path to pink-file.md?",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#relative-paths-5",
    "href": "intro-to-linux-files/linux101.html#relative-paths-5",
    "title": "Linux 101",
    "section": "Relative paths",
    "text": "Relative paths\n../pink-file.md\n\n\n\n\n\n---\nconfig:\n  look: handDrawn\n---\n\nflowchart TD\n    A[\"/home/vscode/ &lt;br&gt; or ~\"] o--o B[red-folder]\n    A o--o C[pink-folder]\n    A o--o D[blue-folder]\n\n    B o--o r1([red-1.txt ])\n    B o--o r2([red-2.txt ])\n    B o--o r3([red-3.txt ])\n\n    C o--o P1[pink-sub-folder]\n    C o--o p2([\"pink-file.md &lt;br&gt;\"])\n    C o--o p3{{\"say_hi.sh &lt;br&gt;\"}}\n\n    P1 o--o p4([\"**helloworld.py** &lt;br&gt;\"])\n    P1 o--o p5([\"pink-data.csv &lt;br&gt;\"])\n\n    D o--o b1([\"**blue.r** &lt;br&gt;\"])\n\n    style P1 fill:#f9f,stroke:#333,stroke-width:10px,color:#333\n    style p2 fill:#ff0,stroke:#333,stroke-width:10px,color:#333\n\n\n\n\n\n\n\nWe can use the command cat with a path to a file to read out the contents: try cat ../pink-file.md",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#recap-1",
    "href": "intro-to-linux-files/linux101.html#recap-1",
    "title": "Linux 101",
    "section": "Recap",
    "text": "Recap\nWe’ve covered an awful lot of commands now!\n\nIf at any point in the course you need a refresher, just click the link at the bottom of the screen to the Cheat Sheet which lists useful commands.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#making-files-and-directories",
    "href": "intro-to-linux-files/linux101.html#making-files-and-directories",
    "title": "Linux 101",
    "section": "Making files and directories",
    "text": "Making files and directories\n\nYou can create a directory with the command mkdir (make directory), and the name of the new directory as an argument:\n\nmkdir new-dir-name\n\nYou can create files with the command touch, and the name of the new file as an argument:\ntouch new-file-name.txt\nYou can provide a path (absolute or relative) instead of a name if you want to create the folder or file somewhere other that the current working directory.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#rules-for-file-and-directory-names",
    "href": "intro-to-linux-files/linux101.html#rules-for-file-and-directory-names",
    "title": "Linux 101",
    "section": "Rules for file and directory names",
    "text": "Rules for file and directory names\n\nDon’t use spaces in names; Linux will think you are entering two separate arguments to a command.\n\n\nBreak up words with hyphens or underscores instead like_this or-this!\n\n\nDon’t begin a name with a hyphen/dash (so no files called -this); Linux will think this is a flag/option to a command.\nStick with numbers, letters, full stops, dashes/hyphens and underscores.\n\n\nSpecial characters like $, %, &, *, / etc. have special meanings on the command line and can lead to confusion!\n\n\nWhen naming files, give them a sensible file ending: .txt, .md, .py etc.\n\nIf you’re working with old files/directories that have spaces in their names, you’ll need to wrap the path in single quotation marks, 'like this.txt'",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#making-files-and-directories-1",
    "href": "intro-to-linux-files/linux101.html#making-files-and-directories-1",
    "title": "Linux 101",
    "section": "Making files and directories",
    "text": "Making files and directories\n\nTry creating some folders and files in your home directory (~)\n\nmkdir path-to-new-folder\ntouch path-to-new-file\n\nIf you want to create multiple nested folders at once, you can use the -p option:\n\n\n_@username → ~ $ mkdir -p new1/new2/new3 ↵\n\n\nYou can create multiple new folders in the same directory by just listing all the new names, separate by spaces:\n\n\n_@username → ~ $ mkdir new1 new2 new3 ↵",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#editing-files",
    "href": "intro-to-linux-files/linux101.html#editing-files",
    "title": "Linux 101",
    "section": "Editing files",
    "text": "Editing files\n\nOftentimes, when you’re doing research on a platform like Aire, you don’t need to do extensive manual editing of files; for example, if you are running multiple R scripts, you would write and test these on your desktop computer and then transfer them over to Aire.\n\n\nSometimes, you might need to edit a file from the command line.\nOne popular tool that is installed on almost all systems is Nano\nTo launch Nano, you just need to type the nano command followed by the name of a file (this can be a new or existing file; Nano will create a file for you if it doesn’t exist)",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#editing-files-with-nano",
    "href": "intro-to-linux-files/linux101.html#editing-files-with-nano",
    "title": "Linux 101",
    "section": "Editing files with Nano",
    "text": "Editing files with Nano\n\n_@username → ~ $ nano new-file.txt ↵\n\nThis will open up a new screen in your terminal…",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#editing-files-with-nano-1",
    "href": "intro-to-linux-files/linux101.html#editing-files-with-nano-1",
    "title": "Linux 101",
    "section": "Editing files with Nano",
    "text": "Editing files with Nano\n\n_   GNU nano 7.2       new-file.txt          \n▮\n_\n_\n_\n_\n\nNew File\n^G Help     ^O Write Out     ^X Exit\n\n\nThe cursor is shown by the rectangle symbol ▮",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#editing-files-with-nano-2",
    "href": "intro-to-linux-files/linux101.html#editing-files-with-nano-2",
    "title": "Linux 101",
    "section": "Editing files with Nano",
    "text": "Editing files with Nano\n\n_   GNU nano 7.2       new-file.txt          \nYou can type in this file;\nyou don’t need to click on it.▮\n_\n_\n_\n\nNew File\n^G Help     ^O Write Out     ^X Exit\n\n\nYou can start typing.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#editing-files-with-nano-3",
    "href": "intro-to-linux-files/linux101.html#editing-files-with-nano-3",
    "title": "Linux 101",
    "section": "Editing files with Nano",
    "text": "Editing files with Nano\n\n_   GNU nano 7.2       new-file.txt          \nTo save your edits,\nhit ^O to write out.\nThis means CTRL and o▮\n_\n_\n\nNew File\n^G Help     ^O Write Out     ^X Exit",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#editing-files-with-nano-4",
    "href": "intro-to-linux-files/linux101.html#editing-files-with-nano-4",
    "title": "Linux 101",
    "section": "Editing files with Nano",
    "text": "Editing files with Nano\n\n_   GNU nano 7.2       new-file.txt          \nTo save your edits,\nhit ^O to write out.\nThis means CTRL and o▮\n_\n  Hit ENTER to accept the filename\nFile Name to write: new-file.txt    \n\n^G Help     ^C Cancel",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#editing-files-with-nano-5",
    "href": "intro-to-linux-files/linux101.html#editing-files-with-nano-5",
    "title": "Linux 101",
    "section": "Editing files with Nano",
    "text": "Editing files with Nano\n\n_   GNU nano 7.2       new-file.txt          \nTo save your edits,\nhit ^X to exit.\nThis means CTRL and x▮\n_\n_\n\nWrote 3 lines\n^G Help     ^O Write Out     ^X Exit\n\n\nThis will close the Nano text editor and return you to the command line.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#using-arrow-keys",
    "href": "intro-to-linux-files/linux101.html#using-arrow-keys",
    "title": "Linux 101",
    "section": "Using arrow keys ↑ ↓",
    "text": "Using arrow keys ↑ ↓\n\nIn the Nano text editor, you cannot click on the text to move the cursor:\n\nYou need to use the arrow keys on your keyboard to navigate the text. ← ↑ → ↓\n\nWhat happens when you use the up and down arrows when you have exited from Nano and are back in the shell?\n\n\n\n\nThe arrow keys allow you to “scroll” through previous commands you’ve used\nIf you don’t want to use a previous command and want to stop scrolling, use ^C to cancel (CTRL and c at the same time)",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#modifying-files-and-directories-mv",
    "href": "intro-to-linux-files/linux101.html#modifying-files-and-directories-mv",
    "title": "Linux 101",
    "section": "Modifying files and directories: mv",
    "text": "Modifying files and directories: mv\nThe mv (move) command allows us to move a file or folder to a specified location:\n\nMove the file file-name to the directory new-location: mv file-name new-location\nMove the directory dir-name to the directory new-location: mv dir-name new-location\n\nIf you move the file or directory to the same location it’s already in, it renames it.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#modifying-files-and-directories-mv-1",
    "href": "intro-to-linux-files/linux101.html#modifying-files-and-directories-mv-1",
    "title": "Linux 101",
    "section": "Modifying files and directories: mv",
    "text": "Modifying files and directories: mv\n\n_@username → ~/somewhere $ cd ↵\n\n_@username → ~ $ touch test-file.txt ↵\n\n\n_@username → ~ $ ls -F ↵\n\n\n_blue-folder/ pink-folder/ red-folder/ test-file.txt\n\n\n_@username → ~ $ mv test-file.txt test-file.md ↵\n\n\n_@username → ~ $ ls -F ↵\n\n\n_blue-folder/ pink-folder/ red-folder/ test-file.md\n\n\n_@username → ~ $ mv test-file.md blue-folder ↵\n\n\n\nWhat’s the result of ls and ls blue-folder now? Repeat this with a new directory in your home directory.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#modifying-files-and-directories-mv-2",
    "href": "intro-to-linux-files/linux101.html#modifying-files-and-directories-mv-2",
    "title": "Linux 101",
    "section": "Modifying files and directories: mv",
    "text": "Modifying files and directories: mv\n\nDo you use the same syntax to move directories and files?\n\nYes, mv works recursively and moves directories (and everything in them).\n\n\nAfter this course, experiment with moving directories around the virtual machine.\n\nDon’t worry about messing up the directory structure - you can rebuild a new VM at any point.\nThis is a safe sandbox to experiment in!\n\nBUT, it’s important to note that you can accidentally overwrite files using mv: this is why it’s useful to practise and get used to using this command in a safe place!",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#modifying-files-and-directories-cp",
    "href": "intro-to-linux-files/linux101.html#modifying-files-and-directories-cp",
    "title": "Linux 101",
    "section": "Modifying files and directories: cp",
    "text": "Modifying files and directories: cp\nThe cp or copy command allows us to copy files or directories to specified locations.\n\n_@username → ~/somewhere $ cd ↵\n\n_@username → ~ $ touch new-test.txt ↵\n_ You can us ls or ls -F to check the file is created\n\n\n_@username → ~ $ nano new-test.txt ↵\n_ Add some text to the file. After saving, check the content with cat:\n_@username → ~ $ cat new-test.txt ↵\n\n\n_@username → ~ $ cp new-test.txt new-test-2.txt ↵\n_ Check the content of new-test-2.txt with cat",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#modifying-files-and-directories-cp-1",
    "href": "intro-to-linux-files/linux101.html#modifying-files-and-directories-cp-1",
    "title": "Linux 101",
    "section": "Modifying files and directories: cp",
    "text": "Modifying files and directories: cp\nThe cp or copy command allows us to copy files or directories to specified locations.\n\n_@username → ~ $ mkdir -p test-dir/sub-dir/sub-sub-dir other-test-dir ↵\n\n_ Explore your new dirs with cd and ls, then return to ~\n\n\n_@username → ~ $ cp test-dir/sub-dir/sub-sub-dir other-test-dir ↵\n\n\n_ cp: -r not specified; omitting directory ‘test-dir/sub-dir/sub-sub-dir’\n_ We need to add a -r to our command, which means “recursive”\n\n\n_@username → ~ $ cp -r test-dir/sub-dir/sub-sub-dir other-test-dir ↵",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#deleting-with-rm",
    "href": "intro-to-linux-files/linux101.html#deleting-with-rm",
    "title": "Linux 101",
    "section": "Deleting with rm",
    "text": "Deleting with rm\nAlmost everyone who’s used Linux before will have a horror story about the command rm (remove), and accidentally deleting files they didn’t mean to.\nBut being able to delete and clean up files is very important, especially when using a shared resource (like Aire) that has storage quotas.\nLet’s clean up all the test files we just made.\n\n_@username → ~ $ ls ↵ Check what files you want to delete\n\n_@username → ~ $ rm new-test.txt new-test-2.txt ↵",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#deleting-with-rm-1",
    "href": "intro-to-linux-files/linux101.html#deleting-with-rm-1",
    "title": "Linux 101",
    "section": "Deleting with rm",
    "text": "Deleting with rm\nDeleting directories\n\n_@username → ~ $ rm test-dir ↵ Delete a directory\n\n_ rm: cannot remove ‘test-dir/’: Is a directory\nLike cp, we need to tell rm we want it to act recursively, with -r\n\n\n_@username → ~ $ rm -r test-dir ↵ Delete a directory\n\n\nThis is very powerful and can quickly delete directories of important data!\nrm does not send things to the recycling bin or equivalent: it hard-deletes them; data is usually not recoverable.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#deleting-with-rm-2",
    "href": "intro-to-linux-files/linux101.html#deleting-with-rm-2",
    "title": "Linux 101",
    "section": "Deleting with rm",
    "text": "Deleting with rm\nA cautionary exercise\nLook at the following command and try to predict what it does:\n\nBreaking it downFace the fear\n\n\nDo not run the following snippet!\nrm -rf *\n\n\nrm: the delete command (remove)\n-r: recursive, so will eat through directories\n-f: force - do not ask for clarification, just delete\n*: a “wildcard” character; instead of providing a file or directory name, this essentially means everything\n\n\n\n\nBefore we go on a break, cd back to your home directory, and experience the abject horror of rm.\n\nRun rm -rf * from /home/vscode. Only do this in your virtual machine on codespaces, never on a research machine\n\n\nUse cd and ls to look around - what does your home directory look like now?",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#rebuild-codespaces",
    "href": "intro-to-linux-files/linux101.html#rebuild-codespaces",
    "title": "Linux 101",
    "section": "Rebuild codespaces",
    "text": "Rebuild codespaces\n\nClick on the &gt;&lt; Codespaces button in the lower left of your screen, then select “Rebuild Container” from the menu that pops up.\nTake a break while it’s re-building (remember to lock your screen if leaving your pc unattended)",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#bash-scripts",
    "href": "intro-to-linux-files/linux101.html#bash-scripts",
    "title": "Linux 101",
    "section": "Bash scripts",
    "text": "Bash scripts\n\nUse ls -F to list out the contents of ~/pink-folder\nWhat are the three categories of content?\n\nWhat kind of file is say_hi.sh?\n\n\n\nThis is an executable file - like a Windows .exe file - you can run it.\nLet’s read it first and predict what it will do:\n\nUse cat say_hi.sh to print out the contents",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#bash-scripts-1",
    "href": "intro-to-linux-files/linux101.html#bash-scripts-1",
    "title": "Linux 101",
    "section": "Bash scripts",
    "text": "Bash scripts\nWhat’s in say_hi.sh?\n#!/bin/sh\necho \"hello!\"\necho \"Running this file prints out a number of greetings\"\necho \"What's your name? (type your name in below)\"\nread yourname\necho \"Nice to meet you, $yourname!\"\n\n\n#!/bin/bash: this is known as “shebang bin bash” tells Linux to use Bash to parse the file - we don’t need to worry about this, beyond knowing to include it at the beginning of a shell script.\nThe echo will just print out (or echo back) any arguments after it.\n\nTry running echo Hello in your terminal\n\nThe read command waits for you to type input and press enter, then saves it to a variable\n\nTry running read greeting and pressing enter\nOn the next line, type Hello, and press enter\nNow, type echo $greeting and press enter\n\nVariables generally start with $",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#bash-scripts-2",
    "href": "intro-to-linux-files/linux101.html#bash-scripts-2",
    "title": "Linux 101",
    "section": "Bash scripts",
    "text": "Bash scripts\nWhat’s in say_hi.sh?\n#!/bin/sh\necho \"hello!\"\necho \"Running this file prints out a number of greetings\"\necho \"What's your name? (type your name in below)\"\nread yourname\necho \"Nice to meet you, $yourname!\"\nWhat do we predict it’s going to do?\n\n_@username → ~/pink-folder $ ./say_hi.sh ↵\nRun using ./ in front of the script name",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#bash-scripts-3",
    "href": "intro-to-linux-files/linux101.html#bash-scripts-3",
    "title": "Linux 101",
    "section": "Bash scripts",
    "text": "Bash scripts\nLet’s create a simple bash script. cd to home and open a new file with Nano:\n\n_@username → ~/pink-folder $ cd ↵\n_@username → ~ $ nano test-script.sh ↵\n\n#!/bin/bash\ntouch test-file-auto.txt\nmkdir new-dir-auto\ncp test-file-auto.txt new-dir-auto\necho \"Put this text in the job report\" &gt; job-report.txt\nSave the file with Nano.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#bash-scripts-4",
    "href": "intro-to-linux-files/linux101.html#bash-scripts-4",
    "title": "Linux 101",
    "section": "Bash scripts",
    "text": "Bash scripts\n\nCheck the contents of your home directory using ls -F\n\nWhat category does your new script show as?\n\nTry using ls -l\n\n\nIt’s just a regular file: we need to make it executable!\n\n_@username → ~ $ chmod +x test-script.sh ↵\n\nThe chmod command changes or modifies file permissions: you need permission to be able to execute a bash script.\n\n+x add executable permissions\ntest-script.sh is the name of the script you want to apply permissions to.\n\nNow, try ls -F again!",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#run-your-bash-script",
    "href": "intro-to-linux-files/linux101.html#run-your-bash-script",
    "title": "Linux 101",
    "section": "Run your Bash script",
    "text": "Run your Bash script\n\n_@username → ~ $ ./test-script.sh ↵\n\nWhat did it do?\n\n\nWhat did the line echo \"Put this text in the job report\" &gt; job-report.txt do?\n\nThe &gt; operator directs the output from echo \"your message\" to the file job-report.txt",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#run-your-bash-script-1",
    "href": "intro-to-linux-files/linux101.html#run-your-bash-script-1",
    "title": "Linux 101",
    "section": "Run your Bash script",
    "text": "Run your Bash script\n\n\nTry to rerun the code, what happens?\nReplace the line mkdir new-dir-auto with mkdir -p new-dir-auto and rerun, what happens?\n\nThe -p option (in addition to allowing you to create nested files) also allows you to try to make a folder, and if it already exists, doesn’t fail",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#run-your-bash-script-2",
    "href": "intro-to-linux-files/linux101.html#run-your-bash-script-2",
    "title": "Linux 101",
    "section": "Run your Bash script",
    "text": "Run your Bash script\n\n\nChange the line echo \"Put this text in the job report\" &gt; job-report.txt to echo \"Put this text in the job report\" &gt;&gt; job-report.txt, what does this do?\n\nThe message now gets appended to the file instead of overwriting\n\nAdd more messages by repeating echo \"message\" &gt; job-report.txt or echo \"message\" &gt;&gt; job-report.txt and seeing how they behave.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#other-scripts",
    "href": "intro-to-linux-files/linux101.html#other-scripts",
    "title": "Linux 101",
    "section": "Other scripts",
    "text": "Other scripts\nIn general, on the HPC system, you will want to run scripts in other languages, like R or Python (amongst many, many others).\n\nThe way you load in a certain language varies depending on the system\n\nYou’ll learn how to do this on Aire at HPC 1\n\nOur system is very simple but has Python and R installed\nOften times, you will want to write a bash script that tells other scripts (written in R, Python etc.) to run",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#r-scripts",
    "href": "intro-to-linux-files/linux101.html#r-scripts",
    "title": "Linux 101",
    "section": "R scripts",
    "text": "R scripts\ncd home, and then into the directory blue-folder:\n\n_@username → ~/wherever $ cd ↵\n\n_@username → ~ $ cd blue-folder ↵\n\n\n_@username → ~/blue-folder $ ls ↵\n\n\n_blue.R\nThis is an R script; if R is installed on the system it can be run with the command Rscript. Check what is in the file before running it with the command cat.\n\n\n_@username → ~/blue-folder $ cat blue.R ↵\n\n\n_print(“Hello World”) Ok, lets run it\n\n\n_@username → ~/blue-folder $ Rscript blue.R ↵",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#r-scripts-1",
    "href": "intro-to-linux-files/linux101.html#r-scripts-1",
    "title": "Linux 101",
    "section": "R scripts",
    "text": "R scripts\n\n\nThe R script ran, and printed the results out onto the screen\n\nWhat if we wanted the results saved to a text file?\n\nIn general, it’s a good idea to do this in R and ensure all your results are saved in the correct data format etc.\nHowever, it can be useful to save printed messages to a file for safe keeping: use a bash script\n\nWhat if we wanted to run multiple R scripts?\n\nWe could write a bash script to do this!",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#r-scripts-bash",
    "href": "intro-to-linux-files/linux101.html#r-scripts-bash",
    "title": "Linux 101",
    "section": "R scripts + bash",
    "text": "R scripts + bash\nLet’s create a bash script called r-bash.sh and save it alongside blue.R; remember you’ll need to do chmod +x r-bash.sh.\n#!/bin/bash\n\nRscript blue.R\nRun this: ./r-bash.sh ; what happens?\n\n#!/bin/bash\n\nRscript blue.R &gt;&gt; output_log.txt\nRun this: ./r-bash.sh ; what happens? Use cat to read the output of output_log.txt",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#python-scripts",
    "href": "intro-to-linux-files/linux101.html#python-scripts",
    "title": "Linux 101",
    "section": "Python scripts",
    "text": "Python scripts\nWe can do the exact same with Python scripts; we only need slightly different commands to run the .py script.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#python-scripts-1",
    "href": "intro-to-linux-files/linux101.html#python-scripts-1",
    "title": "Linux 101",
    "section": "Python scripts",
    "text": "Python scripts\ncd home, and then into the directory pink-folder/pink-sub-folder:\n\n_@username → ~/wherever $ cd ↵\n\n_@username → ~ $ cd pink-folder/pink-sub-folder ↵\n\n\n_@username → ~/pink-folder/pink-subfolder $ ls ↵\n\n\n_helloworld.py pink-data.csv\nCheck what is in the Python file before running it with the command cat.\n\n\n_@username → ~/pink-folder/pink-subfolder $ cat helloworld.py ↵\n\n\n_print(“Hello World”) Ok, lets run it\n\n\n_@username → ~/pink-folder/pink-subfolder $ python helloworld.py ↵",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#python-bash-scripts",
    "href": "intro-to-linux-files/linux101.html#python-bash-scripts",
    "title": "Linux 101",
    "section": "Python + bash scripts",
    "text": "Python + bash scripts\nWrite a bash script that runs the Python script helloworld.py and saves the output to a text file.\n\nRemember to always start with #!/bin/bash\nChange the permissions on your bash script with chmod +x name-of-script.sh\n\n\n#!/bin/bash\n\npython helloworld.py &gt;&gt; output_log.txt\nRun this with ./script-name.sh and check the contents of output_log.txt",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#executable-scripts",
    "href": "intro-to-linux-files/linux101.html#executable-scripts",
    "title": "Linux 101",
    "section": "Executable scripts",
    "text": "Executable scripts\n\nAlways check the contents of any files/scripts you want to run, to ensure you understand what they are doing.\nUse chmod +x script-name.sh to make a bash file executable.\nWhen running Python or R scripts for research, you will need to carefully specify what version of the language (and any libraries/packages) are being used\nBe careful of overwriting data using &gt; to write files.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#next-steps",
    "href": "intro-to-linux-files/linux101.html#next-steps",
    "title": "Linux 101",
    "section": "Next steps",
    "text": "Next steps\n\nA three hour session can introduce the basics, but is not enough to make you feel like a Linux shell expert!\nYour homework: work through the tutorial/session notes for The Unix Shell created by the software carpentry.\nIn order to download the files they use (so that you can follow along all the sessions), we just need the URL of the files: https://swcarpentry.github.io/shell-novice/data/shell-lesson-data.zip\n\n\n_@username → ~/wherever $ cd ↵ Or to wherever you want to download the files\n\n_@username → ~ $ wget https://swcarpentry.github.io/shell-novice/data/shell-lesson-data.zip ↵ Download the zip file (expect lots of output)\n\n\n_@username → ~ $ unzip shell-lesson-data.zip ↵ Unzip the folder (expect lots of output)",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#next-steps-1",
    "href": "intro-to-linux-files/linux101.html#next-steps-1",
    "title": "Linux 101",
    "section": "Next steps",
    "text": "Next steps\n\nwgetunzip\n\n\n\nwget is a really useful command for downloading data from the internet. It can take a range of different options and arguments:\n\nBasic use: wget url-to-data: this downloads the data to the current working directory, with the folder/file name provided by the URL .\nYou can provide a different file name for the download either: wget -O new-nap.zip url-to-data.\nYou can provide a location for the file to download to (not the current working directory): wget -P path/to/folder url-to-data.\nThese are only some of the many, many options available!\n\n\n\n\n\nunzip is necessary if you are downloading compressed/zipped archives (that end in .zip)\n\nBasic use: unzip filename.zip; this will unzip the file in the current working directory, into a folder called filename.\nCheck contents: unzip -l filename.zip will list the contents of the archive without extracting them.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#map",
    "href": "intro-to-linux-files/linux101.html#map",
    "title": "Linux 101",
    "section": "Directory map",
    "text": "Directory map\nUse the back button in your browser to return to the slide you were previously on.\n\n\n\n\n\nflowchart TD\n    START:::hidden --&gt; |cd|A\n    A[/home/vscode/] --&gt;|cd red-folder| B[red-folder/ ]\n    A[/home/vscode/] --&gt;|cd pink-folder| C[pink-folder/ ]\n    A[/home/vscode/] --&gt;|cd blue-folder| D[blue-folder/ ]\n\n    B --- r1([red-1.txt ])\n    B --- r2([red-2.txt ])\n    B --- r3([red-3.txt ])\n\n    C --- |cd pink-sub-folder|P1[pink-sub-folder/ ]\n    C --- p2([pink-file.md ])\n    C --- |./say_hi.sh|p3{{say_hi.sh }}\n\n    P1 --- |python helloworld.py|p4([**helloworld.py** ])\n    P1 --- p5([pink-data.csv ])\n\n    D --- |Rscript blue.r|b1([**blue.r** ])\n\n\n\n\n\n\n\nScroll down to see key:\n\n\n\n\n\nflowchart TD\n  E[folder] --&gt;|CLI argument|F([file])\n  E[folder] --&gt;|CLI argument|G{{executable}}\n\n\n\n\n\n\nYou can use cat filename to print out the content of a file, or nano filename to open the nano text editor. You can also use code filename to open it in vscode on your virtual machine.\nOn the HPC system, you’ll likely use nano to edit code if you ever need to.",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/linux101.html#cheat-sheet",
    "href": "intro-to-linux-files/linux101.html#cheat-sheet",
    "title": "Linux 101",
    "section": "Cheat Sheet",
    "text": "Cheat Sheet\nUse the back button in your browser to return to the slide you were previously on.\nIf you are lost, you can always cd home!\n\n\n\n\n\n\n\nCommand\nDescription\n\n\n\n\ncd\nChange directory to home\n\n\ncd dir-name\nChange directory to dir-name\n\n\npwd\nPrint the current working directory - where am I?\n\n\nname --help\nLoad the manual for name - on Codespaces\n\n\nman name\nLoad the manual for name - on Aire/ARC\n\n\nls\nList the contents of a directory\n\n\ncat file-name\nPrint out the contents of a file called file-name\n\n\nmkdir dir-name\nMake a new directory called dir-name\n\n\ntouch file-name\nMake a new file/update the last-edited date of a file called file-name\n\n\n\nSome more cd commands:\n\n\n\n\n\n\n\nCommand\nDescription\n\n\n\n\ncd ..\nGo up a level to the parent directory\n\n\ncd -\nGo back to the previous directory\n\n\ncd ~/dir-name\nGo to dir-name, a directory in the home directory\n\n\n\nSome more ls commands:\n\n\n\n\n\n\n\nCommand\nDescription\n\n\n\n\nls -F\nList the contents of a dir, with symbols for content type\n\n\nls -a\nList all contents, including hidden files and directories\n\n\nls -l\nList contents, including permissions, the owner and their “group”, and when the content was edited\n\n\n\nCommands for working with files and directories:\n\n\n\n\n\n\n\nCommand\nDescription\n\n\n\n\ncp\n\n\n\nmv\n\n\n\nrm\n\n\n\nmkdir -p dir-name\nMake a new directory call dir-name if it doesn’t already exist",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Linux 101 slides"
    ]
  },
  {
    "objectID": "intro-presentation/intro.html#who-am-i",
    "href": "intro-presentation/intro.html#who-am-i",
    "title": "Research Software Engineering",
    "section": "Who am I?",
    "text": "Who am I?\n\n\nI’m a Research Software Engineer in Research Computing, IT Services\nI completed my PhD in 2024 in the Institute of Geophysics and Tectonics, School of Earth and Environment, University of Leeds\nI have made almost every mistake imaginable when it comes to writing code, managing dependencies, tracking changes, submitting HPC jobs…",
    "crumbs": [
      "Home",
      "Introduction",
      "Introduction Slides"
    ]
  },
  {
    "objectID": "intro-presentation/intro.html#a-good-enough-approach",
    "href": "intro-presentation/intro.html#a-good-enough-approach",
    "title": "Research Software Engineering",
    "section": "A “good enough” approach",
    "text": "A “good enough” approach\n\nDocumentation, guidance, and courses often fall down by aiming for perfection\nThis can lead to people panicking, and not implementing any of the suggestions or tools\nEverything in this course is incremental:\n\nYou will be able to implement some little bits without too much work\nYou can improve and add to this over time",
    "crumbs": [
      "Home",
      "Introduction",
      "Introduction Slides"
    ]
  },
  {
    "objectID": "intro-presentation/intro.html#primm-method",
    "href": "intro-presentation/intro.html#primm-method",
    "title": "Research Software Engineering",
    "section": "PRIMM method",
    "text": "PRIMM method\nPRIMM is a pedagogical method specifically aimed at teaching text-based programming. While research into adult programming learners is very limited (especially in terms of demographics; many key studies that are cited have overwhelmingly homogenous test groups), the PRIMM method has a few key benefits:\n\nIt supports learners with different ability levels and who learn at different speeds;\nIt can be applied by learners even if the course materials are not specifically built with it in mind;\nIt can be applied to asynchronous learning materials (for example, if you are using these notes online on your own).",
    "crumbs": [
      "Home",
      "Introduction",
      "Introduction Slides"
    ]
  },
  {
    "objectID": "intro-presentation/intro.html#primm-method-1",
    "href": "intro-presentation/intro.html#primm-method-1",
    "title": "Research Software Engineering",
    "section": "PRIMM method",
    "text": "PRIMM method\n\nPRIMM\n\n\nThe P in PRIMM stands for predict:\nWhen you first see a command, script, or piece of code, before running it, predict what you think it will do. It’s ok to get this wrong: the important thing is to get into the habit of predicting! This helps to keep you actively engaged and focused, and begins to build an intuitive sense about the structure of commands.\n\nWhat do you think the code is going to do generally?\nWhat do you think the output in your terminal is going to look like?\n\n\n\nThe R in PRIMM stands for run:\n\nRun the code or program;\nHow does the output/effect compare to your prediction?\n\nWhat did you get right?\nWhat did you misinterpret?\n\nDo you understand what happened?\n\n\n\nThe I in PRIMM stands for investigate:\nLet’s dig a little deeper into the structure of code you’ve used.\n\nWhat options or arguments did you use, and what effect did they have?\nCan you find some documentation on the command you used?\n\nDoes the description match how you would describe the code?\n\nIf no, why does your understanding of it diverge?\n\nWhat other options or features are available?\n\n\n\n\nThe first M in PRIMM stands for modify:\n\nTry running the code with different options:\n\nChange only a small thing at a time;\nAlways predict what you think the output will be!\nCompare the actual output with your prediction;\nCompare your understanding to the available documentation.\n\n\nThis stage helps you to gradually increase the difficultly of the tasks you are doing!\n\n\nThe second M in PRIMM stands for make:\nThis stage is about making the code your own.\n\nAt this stage, you can try implementing snippets of code you’ve already learned, but to solve a new or different problem;\nAgain, use the previous stages when you are writing your code: predict what you think will happen, run the code and compare the output to your predictions, and investigate the structure of it, especially if it does not behave how you intended!",
    "crumbs": [
      "Home",
      "Introduction",
      "Introduction Slides"
    ]
  },
  {
    "objectID": "intro-presentation/intro.html#learning-computational-skills",
    "href": "intro-presentation/intro.html#learning-computational-skills",
    "title": "Research Software Engineering",
    "section": "Learning computational skills",
    "text": "Learning computational skills\nRead before you write - research has proven repeatedly the importance of reading and predicting the output of code as a method of learning, over just getting straight into it and writing code.\n\nNovice programmers need to acquire accuracy in tracing code before they can program independently\nTrying to write code first leads to frustration and confusion\n\nLearn in a way that suits you - if that is copying and pasting commands from the slides instead of trying to keep up with typing, that’s ok!",
    "crumbs": [
      "Home",
      "Introduction",
      "Introduction Slides"
    ]
  },
  {
    "objectID": "intro-presentation/intro.html#this-is-an-introductory-workshop",
    "href": "intro-presentation/intro.html#this-is-an-introductory-workshop",
    "title": "Research Software Engineering",
    "section": "This is an introductory workshop",
    "text": "This is an introductory workshop\n\nIf you’re already familiar with the concepts that we’re sharing, it’s likely the sessions discussing those topics will be too basic for you!\nPlease feel free to work on other stuff while you’re here - put headphones on, and jump back in when we’re discussing a topic that’s relevant to you.",
    "crumbs": [
      "Home",
      "Introduction",
      "Introduction Slides"
    ]
  },
  {
    "objectID": "intro-presentation/intro.html#how-this-workshop-is-formatted",
    "href": "intro-presentation/intro.html#how-this-workshop-is-formatted",
    "title": "Research Software Engineering",
    "section": "How this workshop is formatted",
    "text": "How this workshop is formatted\n\nThis workshop is broken up into a series of mini seminars about different topics\nThese seminars will introduce different topics and give you background information that’s often hard to pick up if you’ve learned to use them on your own\nPlease interrupt, ask questions, and discuss!",
    "crumbs": [
      "Home",
      "Introduction",
      "Introduction Slides"
    ]
  },
  {
    "objectID": "intro-presentation/intro.html#how-this-workshop-is-formatted-1",
    "href": "intro-presentation/intro.html#how-this-workshop-is-formatted-1",
    "title": "Research Software Engineering",
    "section": "How this workshop is formatted",
    "text": "How this workshop is formatted\nBut the main aim is to show you how to use all these different tools together…\n\nThis is often somethings that’s missing when we do an online tutorial on how to use git, or read about Python packaging\nMany tutorials and workflows online are tailored towards non-research applications and are difficult to apply to our work",
    "crumbs": [
      "Home",
      "Introduction",
      "Introduction Slides"
    ]
  },
  {
    "objectID": "intro-presentation/intro.html#day-1",
    "href": "intro-presentation/intro.html#day-1",
    "title": "Research Software Engineering",
    "section": "Day 1",
    "text": "Day 1\n\nDay 1 is very focused on these short seminars, introducing different topics, that we will tailor to your group\nIn the morning, we’ll discuss some topics from the following:\n\nDependencies\nRepositories and version control\nTesting\n\nAfter lunch, we’ll discuss some more project-oriented topics like:\n\nTwo-directory structure for computational projects\nWorkflows for setting up new projects\nWays to salvage legacy code/old messy projects",
    "crumbs": [
      "Home",
      "Introduction",
      "Introduction Slides"
    ]
  },
  {
    "objectID": "intro-presentation/intro.html#homework",
    "href": "intro-presentation/intro.html#homework",
    "title": "Research Software Engineering",
    "section": "Homework",
    "text": "Homework\nBetween the two sessions, you’ll have a few tasks:\n\nDepending on your experience, you can brush up on some of the topics we covered\n\nIf you’re experienced, there are some extra exploratory things to try\n\nSetting up a local dev environment:\n\nYou can install and get the tools we used up and running on your local machine\n\nSetting up your mini-project for our second session",
    "crumbs": [
      "Home",
      "Introduction",
      "Introduction Slides"
    ]
  },
  {
    "objectID": "intro-presentation/intro.html#day-2",
    "href": "intro-presentation/intro.html#day-2",
    "title": "Research Software Engineering",
    "section": "Day 2",
    "text": "Day 2\nDay 2 is very hands-on and practical. Over the course of the past week, you’ll have come up with a very simple and small project idea\n\nIn small groups, we will work to:\n\nWrite the foundational code\n\nCreate documentation\nCreate tests\nPackage it\n\nCreate a “project” directory and apply our Package\nLook at how we can automate running our code with bash scripts",
    "crumbs": [
      "Home",
      "Introduction",
      "Introduction Slides"
    ]
  },
  {
    "objectID": "intro-presentation/intro.html#these-notes",
    "href": "intro-presentation/intro.html#these-notes",
    "title": "Research Software Engineering",
    "section": "These notes",
    "text": "These notes\n\nDuring the course, of course you can just ask me anything you want!\nDuring the week and a half between sessions, you can also use the comments section on these notes to look for help.\nQuestions for clarification will also help your fellow cohort!",
    "crumbs": [
      "Home",
      "Introduction",
      "Introduction Slides"
    ]
  },
  {
    "objectID": "intro-to-linux-files/intro-to-linux-page.html",
    "href": "intro-to-linux-files/intro-to-linux-page.html",
    "title": "Linux 101",
    "section": "",
    "text": "This is a modified version of the course presentation for HPC0: Introduction to Linux for HPC, if you’re very unfamiliar with the material shown here, there’s some additional homework for you between courses.\nYou can follow along with the presentation notes here:\nLaunch fullscreen presentation ⤢\nLaunch your virtual machine to test out these notes here:\nLaunch codespaces virtual machine ⇗",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Intro to Linux"
    ]
  },
  {
    "objectID": "intro-to-linux-files/intro-to-linux-page.html#frequently-used-commands-cheat-sheet",
    "href": "intro-to-linux-files/intro-to-linux-page.html#frequently-used-commands-cheat-sheet",
    "title": "Linux 101",
    "section": "Frequently used commands: cheat sheet",
    "text": "Frequently used commands: cheat sheet\n\n\n\n\n\n\n\nCommand\nDescription\n\n\n\n\ncd\nChange directory to home\n\n\ncd dir-name\nChange directory to dir-name\n\n\npwd\nPrint the current working directory - where am I?\n\n\nname --help\nLoad the manual for name - on Codespaces\n\n\nman name\nLoad the manual for name - on Aire/ARC\n\n\nls\nList the contents of a directory\n\n\ncat file-name\nPrint out the contents of a file called file-name\n\n\nmkdir dir-name\nMake a new directory called dir-name\n\n\ntouch file-name\nMake a new file/update the last-edited date of a file called file-name\n\n\n\nSome more cd commands:\n\n\n\n\n\n\n\nCommand\nDescription\n\n\n\n\ncd ..\nGo up a level to the parent directory\n\n\ncd -\nGo back to the previous directory\n\n\ncd ~/dir-name\nGo to dir-name, a directory in the home directory\n\n\n\nSome more ls commands:\n\n\n\n\n\n\n\nCommand\nDescription\n\n\n\n\nls -F\nList the contents of a dir, with symbols for content type\n\n\nls -a\nList all contents, including hidden files and directories\n\n\nls -l\nList contents, including permissions, the owner and their “group”, and when the content was edited\n\n\n\nCommands for working with files and directories:\n\n\n\n\n\n\n\nCommand\nDescription\n\n\n\n\ncp\n\n\n\nmv\n\n\n\nrm\n\n\n\nmkdir -p dir-name\nMake a new directory call dir-name if it doesn’t already exist",
    "crumbs": [
      "Home",
      "Basic Linux",
      "Intro to Linux"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "RSE: How to",
    "section": "",
    "text": "These module notes aim to provide you with a friendly introduction to Research Software Engineering (RSE) or Research Software Development. This is an evolution of the course notes Sustainable Software Development (Murphy Quinlan 2024), intended to be more flexible and not reliant on a server.\nThis course consists of a series of different topics and notes, usually including a brief presentation and some exercises for you to follow along with. Where relevant, I’ve cited various articles, and have usually linked to a variety of different resources.",
    "crumbs": [
      "Home",
      "Introduction",
      "Course page"
    ]
  },
  {
    "objectID": "index.html#why-do-software-engineering-skills-matter-to-researchers",
    "href": "index.html#why-do-software-engineering-skills-matter-to-researchers",
    "title": "RSE: How to",
    "section": "Why do software engineering skills matter to researchers?",
    "text": "Why do software engineering skills matter to researchers?\nResearch computing competency and specifically programming skills are becoming ever more important in our data-driven world: Jacobs et al. (2016) argues that “we are rapidly approaching a point where innovations [in research] will primarily come from those who are able to translate an idea into an algorithm, and then into computer code.”\nResearch software engineering skills are the lab tools and competencies of the computational research world; much like practical lab safety training, researchers often pick up bad habits (ask me about my fear of HF acid). Also similarly to lab processes, procedures, and best practises, software engineering is awash with bizarre jargon and is very difficult to navigate without the support of a jaded old PhD student who has made every mistake imaginable (hello, it’s me, I escaped my PhD over a year ago now).\nThis course does not provide the holy grail, the singular correct way of doing things; instead, it should hopefully make the process of writing good, robust, reproducible code a little bit more straighforward.",
    "crumbs": [
      "Home",
      "Introduction",
      "Course page"
    ]
  },
  {
    "objectID": "index.html#current-course",
    "href": "index.html#current-course",
    "title": "RSE: How to",
    "section": "Current course",
    "text": "Current course\nThe most recent/current iteration of this course is:\nResearch Software Engineering: SOEE5261M\nNote that the order of delivery/course contents may vary depending on pre-course surveys etc.",
    "crumbs": [
      "Home",
      "Introduction",
      "Course page"
    ]
  },
  {
    "objectID": "index.html#how-to-use-this-resource",
    "href": "index.html#how-to-use-this-resource",
    "title": "RSE: How to",
    "section": "How to use this resource",
    "text": "How to use this resource\nThere’s a lot of materal here to absorb, so here are some guidelines to help you make the most of it. This material is also covered in the presentation linked below.\nLaunch fullscreen presentation ⤢ \n\n1. Use the PRIMM method where possible\nThe PRIMM method is a method to specifically learn a programming language (Sentance, Waite, and Kallia 2019), but is generally useful for learning computational commands etc. It’s helpful for you as a learner to understand the PRIMM structure so you can apply it while working through this course. Not every step will be relevant or used at every stage of the course!\n\nWhat’s PRIMM?PRIMM\n\n\nPRIMM is a pedagogical method specifically aimed at teaching text-based programming. While research into adult programming learners is very limited (especially in terms of demographics; many key studies that are cited have overwhelmingly homogenous test groups), the PRIMM method has a few key benefits:\n\nIt supports learners with different ability levels and who learn at different speeds;\nIt can be applied by learners even if the course materials are not specifically built with it in mind;\nIt can be applied to asynchronous learning materials (for example, if you are using these notes online on your own).\n\n\n\nThe P in PRIMM stands for predict:\nWhen you first see a command, script, or piece of code, before running it, predict what you think it will do. It’s ok to get this wrong: the important thing is to get into the habit of predicting! This helps to keep you actively engaged and focused, and begins to build an intuitive sense about the structure of commands.\n\nWhat do you think the code is going to do generally?\nWhat do you think the output in your terminal is going to look like?\n\n\n\nThe R in PRIMM stands for run:\n\nRun the code or program;\nHow does the output/effect compare to your prediction?\n\nWhat did you get right?\nWhat did you misinterpret?\n\nDo you understand what happened?\n\n\n\nThe I in PRIMM stands for investigate:\nLet’s dig a little deeper into the structure of code you’ve used.\n\nWhat options or arguments did you use, and what effect did they have?\nCan you find some documentation on the command you used?\n\nDoes the description match how you would describe the code?\n\nIf no, why does your understanding of it diverge?\n\nWhat other options or features are available?\n\n\n\n\nThe first M in PRIMM stands for modify:\n\nTry running the code with different options:\n\nChange only a small thing at a time;\nAlways predict what you think the output will be!\nCompare the actual output with your prediction;\nCompare your understanding to the available documentation.\n\n\nThis stage helps you to gradually increase the difficultly of the tasks you are doing!\n\n\nThe second M in PRIMM stands for make:\nThis stage is about making the code your own.\n\nAt this stage, you can try implementing snippets of code you’ve already learned, but to solve a new or different problem;\nAgain, use the previous stages when you are writing your code: predict what you think will happen, run the code and compare the output to your predictions, and investigate the structure of it, especially if it does not behave how you intended!\n\n\n\n\n\n\n2. Kick back, relax, and do something else when you know something\nToo frequently, I have attended broad-level, apparently introductory courses that have catered to the fastest in the class.\nThe aim of this course is to demystify aspects of research software engineering, like dependency management, version control, and project directory structure. These topics are basic skills needed for pursuing research in the computational field. Certain demographics are less likely to learn these skills in an informal setting, meaning that classes like this are their main access to these topics.\nI am interested in helping the students who do not already know everything about these topics, and will not be pacing the course for the fastest in the group who have pre-existing knowledge. With that said, I know there is nothing more boring than sitting through a class where you already know all the material - please feel free to use this time to do extra reading, work on projects, do various administrative work; stick on headphones if you like, and join back in when something relevant comes up.\n\n\n3. Learn in a way that suits you\nRead before you write - research has proven repeatedly the importance of reading and predicting the output of code as a method of learning, over just getting straight into it and writing code.\n\nNovice programmers need to acquire accuracy in tracing code before they can program independently\nTrying to write code first leads to frustration and confusion\n\nHowever, with that said learn in a way that suits you - if that is copying and pasting commands from the slides instead of trying to keep up with typing, that’s ok! Also, if that means taking handwritten notes and not typing, that’s also fine!\nPlease feel free to:\n\nGet up and stretch when you need, leave for breaks, and stretch your eyes by looking away from the screen;\nWear headphones for background music if it helps you focus;\nKick off your shoes and sit comfortably;\nDo whatever else helps you learn!",
    "crumbs": [
      "Home",
      "Introduction",
      "Course page"
    ]
  },
  {
    "objectID": "managing-dependencies/conda-skills.html",
    "href": "managing-dependencies/conda-skills.html",
    "title": "conda skills",
    "section": "",
    "text": "Conda is a widely used package management system which allows you to isolate different Python “environments” from each other, allowing you to use different versions of libraries or modules for different projects. However, mismanagement of packages can lead to dependency hell with tangled environments and incompatible versions of different modules.\nThis presentation aims to provide you with a workflow for using conda that ensures:\n\nYou can rebuild your environment on a different computer/platform without problem\nThat you can record exact dependencies for the sake of reproducibility\nThat you can update your environment without it breaking (even if you have pip dependencies too!)\nYou don’t get tangled up in licensing issues.\n\nTo read the contents of this presentation in article format, please see my blog post on using conda;\nLaunch fullscreen presentation ⤢\n\n\n\n Back to topCitationBibTeX citation:@online{murphy_quinlan2025,\n  author = {Murphy Quinlan, Maeve},\n  title = {Conda Skills},\n  date = {2025-02-18},\n  url = {https://murphyqm.github.io/research-software-dev/managing-dependencies/conda-skills.html},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMurphy Quinlan, Maeve. 2025. “Conda Skills.” February 18,\n2025. https://murphyqm.github.io/research-software-dev/managing-dependencies/conda-skills.html.",
    "crumbs": [
      "Home",
      "Managing dependencies",
      "Conda skills"
    ]
  },
  {
    "objectID": "managing-dependencies/dependencies-intro.html",
    "href": "managing-dependencies/dependencies-intro.html",
    "title": "Dependencies 101",
    "section": "",
    "text": "Dependencies are the versions of different packages/modules that your code depends on, for example the version of Python you are using, and any libraries you have to import, like matplotlib, scipy, tensorflow etc.\nDependencies are an important thing to keep track of when building scientific code. How many different external libraries does your code depend on? What versions of these libraries does it need? How do you install and update these different libraries?\nLaunch fullscreen presentation ⤢",
    "crumbs": [
      "Home",
      "Managing dependencies",
      "Basic dependencies in Python"
    ]
  },
  {
    "objectID": "managing-dependencies/dependencies-intro.html#package-management-for-python",
    "href": "managing-dependencies/dependencies-intro.html#package-management-for-python",
    "title": "Dependencies 101",
    "section": "Package management for Python",
    "text": "Package management for Python\nIn Python, there are lots of different ways to install and manage packages and dependencies. These different tools generally involve using virtual environments in order to keep the dependencies for different projects separate and tidy. Some package installation and management tools include:\n\nConda/Mamba\n\nYou can install conda with Miniforge\n\npip and Pipenv\npixi\nPoetry\nuv\n\nYou can read more about Python package management tool recommendations here. The package management tool you use will vary depending on whether you want to build your code into a package itself, or are relying primarily on external libraries. Some of these package managers include entire workflows for building and publishing Python packages, while others focus on organising pre-existing packages.\n\nPackage management for other coding languages\nNote that I do not have as extensive experience managing projects, dependencies and packages in the following languages so please proceed with caution.\nPackage management in R\nconda for R: you can install conda via Miniforge as linked above, and then install R packages through this following these instructions for R with conda.\nrenv: the reproducible environment package for R has some very nice introductory documentation.\nPackage management in Julia\nPkg: Pkg is Julia’s built-in package manager.\n\nIn research, a lot of people rely on conda: you can read more about perfecting your conda environment in this blog post.",
    "crumbs": [
      "Home",
      "Managing dependencies",
      "Basic dependencies in Python"
    ]
  },
  {
    "objectID": "managing-dependencies/dependencies-old-projects.html",
    "href": "managing-dependencies/dependencies-old-projects.html",
    "title": "Salvaging old code: managing dependencies",
    "section": "",
    "text": "Ok, so we’ve looked at the basic behind-the-scenes of what dependency management is, and some of the different options available. But how do you retroactively apply dependency management to an existing messy code project?. While we can’t record things that we’ve done in the past, we can start from now.",
    "crumbs": [
      "Home",
      "Managing dependencies",
      "Figuring out dependencies for old code"
    ]
  },
  {
    "objectID": "managing-dependencies/dependencies-old-projects.html#step-0-pick-your-package-manager",
    "href": "managing-dependencies/dependencies-old-projects.html#step-0-pick-your-package-manager",
    "title": "Salvaging old code: managing dependencies",
    "section": "Step 0: Pick your package manager",
    "text": "Step 0: Pick your package manager\nWhile I’ve mentioned a whole host of options for Python package managers above, I’m going to work through some basic instructions for just two options: conda (installed via miniforge) and pixi.\n\ncondapixi\n\n\nIf you have never before used a package management system, or work in science, conda might be the best choice for you. See this conda blogpost (Murphy Quinlan 2024) for useful links to installation guides, and an in-depth use guide.\nConda is very widely used and recognised, especially amongst researchers in science and medical fields.\n\nMiniforge repository\nMiniforge License\nStep-by-step Miniforge tutorial\n\n\n\nPixi is great if you are using a lot of conda and PyPI packages together (which can get messy); it also can work with a pyproject.toml file if you plan on packaging your code at some point. It is very fast.\nHave a read through this blog post on testing pixi (Ma 2024).\n\nPixi repository\nPixi License\nPixi Python tutorial",
    "crumbs": [
      "Home",
      "Managing dependencies",
      "Figuring out dependencies for old code"
    ]
  },
  {
    "objectID": "managing-dependencies/dependencies-old-projects.html#step-1-manually-record-what-libraries-you-use",
    "href": "managing-dependencies/dependencies-old-projects.html#step-1-manually-record-what-libraries-you-use",
    "title": "Salvaging old code: managing dependencies",
    "section": "Step 1: Manually record what libraries you use",
    "text": "Step 1: Manually record what libraries you use\nScroll through all the scripts you use in your project, and record all the packages that you call as imports across these different Python files and Jupyter notebooks (*.py and *.ipynb files).\nFor example, I have a series of Python files in my project folder with the following first few lines:\n# file1.ipynb\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n# file2.py\nimport numpy as np\nimport pandas as pd\nMy list of jotted down dependencies are then:\n\nnumpy\nmatplotlib 1\nseaborn\npandas\njupyter 2\n\n\nPlain system PythonAn old environment\n\n\nIf until now you’ve been running your Python programs directly using your system’s Python (so you have never set up an environment), let’s just see what versions of packages your system is using.\nFirst, check the version of Python by running the following from the command line:\npython --version\nFrom the command line, run the following (replacing numpy with your dependencies in turn):\npython -c \"import numpy; print(numpy.__version__)\"\nThis gives you an idea of what version of each of these dependencies your system has been using. Copy these down.\n\n\nIf you have been using an environment but it’s become messy or broken and you want to start over, there are a few different options for you.\nDepending on the package management software you used to build the environment, the method to export the environment will be different. Search your package manager software name and “export dependencies” to see how to do this automatically.\nAlternatively, if you’ve already manually collected the libraries used, and you know there’s a lot of bloat in your existing environment (lot’s of unused packages), you can instead activate the environment and then from the command line run the following (replacing numpy with your dependencies in turn):\npython -c \"import numpy; print(numpy.__version__)\"\nAlso check the version of Python by running the following from the command line (again, with the environment active):\npython --version\nThis gives you an idea of what version of each of these dependencies your system has been using. Copy these down.",
    "crumbs": [
      "Home",
      "Managing dependencies",
      "Figuring out dependencies for old code"
    ]
  },
  {
    "objectID": "managing-dependencies/dependencies-old-projects.html#step-2-create-a-new-environment",
    "href": "managing-dependencies/dependencies-old-projects.html#step-2-create-a-new-environment",
    "title": "Salvaging old code: managing dependencies",
    "section": "Step 2: Create a new environment",
    "text": "Step 2: Create a new environment\nNow that you know what packages you want to include in your environment, you can create a new environment. In the last step, we recorded the versions of different libraries we were using: right now, we’re not going to worry about pinning our versions to match our previous set-up unless something goes wrong. We’ll keep our manually recorded version numbers to hand just-in-case.\n\ncondapixi\n\n\nTo create a new conda environment, you need to create an environment.yml file. This will contain a list of your dependencies, like this:\nname: my-env-name\n\ndependencies:\n  - python=3.12\n  - numpy\n  - matplotlib\n  - pandas\n  - seaborn\n  - jupyter\nPut this in your project folder. I’ve just pinned the Python version as an example of how to pin a specific version. Then, from the command line (within this folder), run:\nconda env create -f environment.yml\nIf you need to add pip dependencies, then your environment.yml will look like this:\nname: my-env-name\n\ndependencies:\n  - python=3.12\n  - numpy\n  - matplotlib\n  - pandas\n  - seaborn\n  - jupyter\n  - pip\n  - pip:\n    - black\nNote: mixing conda and pip will cause issues; please read this post on mixing conda and pip (Murphy Quinlan 2024).\n\n\nTo create a new pixi environment for your pre-existing project, from inside the project directory run:\npixi init\nThis will create a file called pixi.toml that will look something like this:\n[project]\nauthors = [\"\"]\nchannels = [\"conda-forge\"]\ndescription = \"Add a short description here\"\nname = \"folder-name\"\nplatforms = [\"linux-64\"]\nversion = \"0.1.0\"\n\n[tasks]\n\n[dependencies]\n\nQuick addManual addPyPI dependencies\n\n\nWe can add pinned and unpinned dependencies from the command line:\npixi add python=3.12 numpy matplotlib pandas seaborn jupyter\nThis will fill in the dependencies section of our pixi.toml file with some automatically assigned version restrictions (given our pinned Python version):\n[dependencies]\npython = \"3.12.*\"\nnumpy = \"&gt;=2.2.1,&lt;3\"\nmatplotlib = \"&gt;=3.10.0,&lt;4\"\npandas = \"&gt;=2.2.3,&lt;3\"\nseaborn = \"&gt;=0.13.2,&lt;0.14\"\njupyter = \"&gt;=1.1.1,&lt;2\"\n\n\nWe can also fill in our dependencies (with as-of-yet no pinned versions except for Python as an example):\n[dependencies]\npython = \"3.12.*\"\nnumpy = \"*\"\nmatplotlib = \"*\"\npandas = \"*\"\nseaborn = \"*\"\njupyter = \"*\"\n\n\nIf you need any pip/PyPI dependencies, then simply add this section to the file:\n[pypi-dependencies]\nblack = \"*\"\nAlternatively, run this from the command line:\npixi add --pypi black\nwhich will add the following to your pixi.toml:\n[pypi-dependencies]\nblack = \"&gt;=24.10.0, &lt;25\"\n\n\n\nSave any changes to your pixi.toml file, then back in the command line in the folder containing your pixi.toml, run the following:\npixi install\nThis will install the listed packages and create a pixi.lock file.\nRead the Pixi docs on lockfiles.",
    "crumbs": [
      "Home",
      "Managing dependencies",
      "Figuring out dependencies for old code"
    ]
  },
  {
    "objectID": "managing-dependencies/dependencies-old-projects.html#step-3-activate-the-environment",
    "href": "managing-dependencies/dependencies-old-projects.html#step-3-activate-the-environment",
    "title": "Salvaging old code: managing dependencies",
    "section": "Step 3: Activate the environment",
    "text": "Step 3: Activate the environment\n\ncondapixi\n\n\nTo activate your conda environment, from the command line run:\nconda activate my-env-name\nand then either launch your Jupyter notebook or run your Python script.\n\n\nFrom the project folder, run:\npixi shell\nand then either launch your Jupyter notebook or run your Python script.",
    "crumbs": [
      "Home",
      "Managing dependencies",
      "Figuring out dependencies for old code"
    ]
  },
  {
    "objectID": "managing-dependencies/dependencies-old-projects.html#step-4-export-your-environment",
    "href": "managing-dependencies/dependencies-old-projects.html#step-4-export-your-environment",
    "title": "Salvaging old code: managing dependencies",
    "section": "Step 4: Export your environment",
    "text": "Step 4: Export your environment\nExporting and recording your environment is an important step in ensuring reproducibility and reusability of your code.\n\ncondapixi\n\n\nThere are a few different options when it comes to exporting your conda environment. Read more information here on the different ways to export.\nTo export a detailed record of your environment for reproducibility, use the following command:\nconda env export &gt; env-record.yml\nNote: this might not be installable on a different machine due to build dependencies - see this post for more details on exporting.\n\n\nFrom the project folder, run:\npixi shell\nand then either launch your Jupyter notebook or run your Python script.\n\n\n\nNow you should have a nice, reusable environment that ensures you code can run on other people’s machines!",
    "crumbs": [
      "Home",
      "Managing dependencies",
      "Figuring out dependencies for old code"
    ]
  },
  {
    "objectID": "managing-dependencies/dependencies-old-projects.html#footnotes",
    "href": "managing-dependencies/dependencies-old-projects.html#footnotes",
    "title": "Salvaging old code: managing dependencies",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nWe don’t specify the module (the pyplot part of matplotlib.pyplot) in our requirements.↩︎\nWhile jupyter isn’t imported in our files, we are using a Jupyter Notebook (file1.ipynb required Jupyter) so this must be included in our dependencies.↩︎",
    "crumbs": [
      "Home",
      "Managing dependencies",
      "Figuring out dependencies for old code"
    ]
  },
  {
    "objectID": "version_control/version_control_slides.html#what-does-git-do-2",
    "href": "version_control/version_control_slides.html#what-does-git-do-2",
    "title": "Version control",
    "section": "What does git do?",
    "text": "What does git do?\n\n\nNew version of python-file.py\n\n1 # This is a comment\n2 import matplotlib.pyplot as plt\n3 import numpy as np\n4 x = [1, 2, 3, 4, 5]\n5 y = [3, 4, 5, 6, 7]\n6 plt.scatter(x, y)\n6 plt.plot(x, y)\n\nLine 3 added, line 6 removed, line 6 added.\n\nAssociated git commit\n\nFile: python-file.py\nCommit hash: u87wy9o2\nCommit message: change plotting method\n+++ 3 import numpy as np\n— 6 plt.scatter(x, y)\n+++ 6 plt.plot(x, y)",
    "crumbs": [
      "Home",
      "Version control with git",
      "Version control intro slides"
    ]
  }
]